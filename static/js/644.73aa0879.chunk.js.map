{"version":3,"file":"static/js/644.73aa0879.chunk.js","mappings":"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","sources":["../node_modules/@tiptap/core/src/jsx-runtime.ts","../node_modules/@tiptap/extension-blockquote/src/blockquote.tsx","../node_modules/@tiptap/extension-bold/src/bold.tsx","../node_modules/@tiptap/extension-code/src/code.ts","../node_modules/@tiptap/extension-code-block/src/code-block.ts","../node_modules/@tiptap/extension-document/src/document.ts","../node_modules/@tiptap/extension-hard-break/src/hard-break.ts","../node_modules/@tiptap/extension-heading/src/heading.ts","../node_modules/@tiptap/extension-horizontal-rule/src/horizontal-rule.ts","../node_modules/@tiptap/extension-italic/src/italic.ts","../node_modules/linkifyjs/dist/linkify.mjs","../node_modules/@tiptap/extension-link/src/helpers/whitespace.ts","../node_modules/@tiptap/extension-link/src/link.ts","../node_modules/@tiptap/extension-link/src/helpers/autolink.ts","../node_modules/@tiptap/extension-link/src/helpers/clickHandler.ts","../node_modules/@tiptap/extension-link/src/helpers/pasteHandler.ts","../node_modules/@tiptap/extension-list/src/bullet-list/bullet-list.ts","../node_modules/@tiptap/extension-list/src/item/list-item.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/index.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/findListItemPos.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/getNextListDepth.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/hasListBefore.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/hasListItemBefore.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/listItemHasSubList.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/handleBackspace.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/nextListIsDeeper.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/nextListIsHigher.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/handleDelete.ts","../node_modules/@tiptap/extension-list/src/keymap/listHelpers/hasListItemAfter.ts","../node_modules/@tiptap/extension-list/src/keymap/list-keymap.ts","../node_modules/@tiptap/extension-list/src/ordered-list/utils.ts","../node_modules/@tiptap/extension-list/src/ordered-list/ordered-list.ts","../node_modules/@tiptap/extension-list/src/task-item/task-item.ts","../node_modules/@tiptap/extension-list/src/task-list/task-list.ts","../node_modules/@tiptap/extension-paragraph/src/paragraph.ts","../node_modules/@tiptap/extension-list/src/kit/index.ts","../node_modules/@tiptap/extension-strike/src/strike.ts","../node_modules/@tiptap/extension-text/src/text.ts","../node_modules/@tiptap/extension-text-align/src/index.ts","../node_modules/@tiptap/extension-text-align/src/text-align.ts","../node_modules/@tiptap/extension-underline/src/underline.ts","../node_modules/@puckeditor/core/dist/chunk-2CNEFIQP.mjs"],"sourcesContent":["export type Attributes = Record<string, any>\n\nexport type DOMOutputSpecElement = 0 | Attributes | DOMOutputSpecArray\n/**\n * Better describes the output of a `renderHTML` function in prosemirror\n * @see https://prosemirror.net/docs/ref/#model.DOMOutputSpec\n */\nexport type DOMOutputSpecArray =\n  | [string]\n  | [string, Attributes]\n  | [string, 0]\n  | [string, Attributes, 0]\n  | [string, Attributes, DOMOutputSpecArray | 0]\n  | [string, DOMOutputSpecArray]\n\n// JSX types for Tiptap's JSX runtime\n// These types only apply when using @jsxImportSource @tiptap/core\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace JSX {\n  export type Element = DOMOutputSpecArray\n  export interface IntrinsicElements {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any\n  }\n  export interface ElementChildrenAttribute {\n    children: unknown\n  }\n}\n\nexport type JSXRenderer = (\n  tag: 'slot' | string | ((props?: Attributes) => DOMOutputSpecArray | DOMOutputSpecElement),\n  props?: Attributes,\n  ...children: JSXRenderer[]\n) => DOMOutputSpecArray | DOMOutputSpecElement\n\nexport function Fragment(props: { children: JSXRenderer[] }) {\n  return props.children\n}\n\nexport const h: JSXRenderer = (tag, attributes) => {\n  // Treat the slot tag as the Prosemirror hole to render content into\n  if (tag === 'slot') {\n    return 0\n  }\n\n  // If the tag is a function, call it with the props\n  if (tag instanceof Function) {\n    return tag(attributes)\n  }\n\n  const { children, ...rest } = attributes ?? {}\n\n  if (tag === 'svg') {\n    throw new Error('SVG elements are not supported in the JSX syntax, use the array syntax instead')\n  }\n\n  // Otherwise, return the tag, attributes, and children\n  return [tag, rest, children]\n}\n\n// See\n// https://esbuild.github.io/api/#jsx-import-source\n// https://www.typescriptlang.org/tsconfig/#jsxImportSource\n\nexport { h as createElement, h as jsx, h as jsxDEV, h as jsxs }\n","/** @jsxImportSource @tiptap/core */\nimport { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nexport interface BlockquoteOptions {\n  /**\n   * HTML attributes to add to the blockquote element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blockQuote: {\n      /**\n       * Set a blockquote node\n       */\n      setBlockquote: () => ReturnType\n      /**\n       * Toggle a blockquote node\n       */\n      toggleBlockquote: () => ReturnType\n      /**\n       * Unset a blockquote node\n       */\n      unsetBlockquote: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a blockquote to a `>` as input.\n */\nexport const inputRegex = /^\\s*>\\s$/\n\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */\nexport const Blockquote = Node.create<BlockquoteOptions>({\n  name: 'blockquote',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'block+',\n\n  group: 'block',\n\n  defining: true,\n\n  parseHTML() {\n    return [{ tag: 'blockquote' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <blockquote {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </blockquote>\n    )\n  },\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('blockquote', undefined, helpers.parseChildren(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    // Use a single '>' prefix regardless of nesting level\n    // Nested blockquotes will add their own '>' prefix recursively\n    const prefix = '>'\n    const result: string[] = []\n\n    node.content.forEach(child => {\n      // Render each child node as an array so it gets processed properly\n      const childContent = h.renderChildren([child])\n      const lines = childContent.split('\\n')\n\n      const linesWithPrefix = lines.map(line => {\n        // Don't add prefix to empty lines\n        if (line.trim() === '') {\n          return prefix\n        }\n\n        // Nested blockquotes will already have their own prefixes\n        // We just need to add our own prefix at the start\n        return `${prefix} ${line}`\n      })\n\n      result.push(linesWithPrefix.join('\\n'))\n    })\n\n    // Add separator lines between children\n    return result.join(`\\n${prefix}\\n`)\n  },\n\n  addCommands() {\n    return {\n      setBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.wrapIn(this.name)\n        },\n      toggleBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.toggleWrap(this.name)\n        },\n      unsetBlockquote:\n        () =>\n        ({ commands }) => {\n          return commands.lift(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","/** @jsxImportSource @tiptap/core */\nimport { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface BoldOptions {\n  /**\n   * HTML attributes to add to the bold element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bold: {\n      /**\n       * Set a bold mark\n       */\n      setBold: () => ReturnType\n      /**\n       * Toggle a bold mark\n       */\n      toggleBold: () => ReturnType\n      /**\n       * Unset a bold mark\n       */\n      unsetBold: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches bold text via `**` as input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/\n\n/**\n * Matches bold text via `**` while pasting.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g\n\n/**\n * Matches bold text via `__` as input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/\n\n/**\n * Matches bold text via `__` while pasting.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g\n\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */\nexport const Bold = Mark.create<BoldOptions>({\n  name: 'bold',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'strong',\n      },\n      {\n        tag: 'b',\n        getAttrs: node => (node as HTMLElement).style.fontWeight !== 'normal' && null,\n      },\n      {\n        style: 'font-weight=400',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-weight',\n        getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value as string) && null,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return (\n      <strong {...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)}>\n        <slot />\n      </strong>\n    )\n  },\n\n  markdownTokenName: 'strong',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'strong' token to bold mark\n    return helpers.applyMark('bold', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `**${h.renderChildren(node)}**`\n  },\n\n  addCommands() {\n    return {\n      setBold:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleBold:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetBold:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-b': () => this.editor.commands.toggleBold(),\n      'Mod-B': () => this.editor.commands.toggleBold(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface CodeOptions {\n  /**\n   * The HTML attributes applied to the code element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    code: {\n      /**\n       * Set a code mark\n       */\n      setCode: () => ReturnType\n      /**\n       * Toggle inline code\n       */\n      toggleCode: () => ReturnType\n      /**\n       * Unset a code mark\n       */\n      unsetCode: () => ReturnType\n    }\n  }\n}\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick as the final character.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */\nexport const inputRegex = /(^|[^`])`([^`]+)`(?!`)$/\n\n/**\n * Matches inline code while pasting.\n */\nexport const pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g\n\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */\nexport const Code = Mark.create<CodeOptions>({\n  name: 'code',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  excludes: '_',\n\n  code: true,\n\n  exitable: true,\n\n  parseHTML() {\n    return [{ tag: 'code' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['code', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'codespan',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'codespan' token to code mark\n    // For codespan tokens, we use the raw text content, not tokens\n    return helpers.applyMark('code', [{ type: 'text', text: token.text || '' }])\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return `\\`${h.renderChildren(node.content)}\\``\n  },\n\n  addCommands() {\n    return {\n      setCode:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleCode:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetCode:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-e': () => this.editor.commands.toggleCode(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\nimport { Plugin, PluginKey, Selection, TextSelection } from '@tiptap/pm/state'\n\nconst DEFAULT_TAB_SIZE = 4\n\nexport interface CodeBlockOptions {\n  /**\n   * Adds a prefix to language classes that are applied to code tags.\n   * @default 'language-'\n   */\n  languageClassPrefix: string | null | undefined\n  /**\n   * Define whether the node should be exited on triple enter.\n   * @default true\n   */\n  exitOnTripleEnter: boolean | null | undefined\n  /**\n   * Define whether the node should be exited on arrow down if there is no node after it.\n   * @default true\n   */\n  exitOnArrowDown: boolean | null | undefined\n  /**\n   * The default language.\n   * @default null\n   * @example 'js'\n   */\n  defaultLanguage: string | null | undefined\n  /**\n   * Enable tab key for indentation in code blocks.\n   * @default false\n   */\n  enableTabIndentation: boolean | null | undefined\n  /**\n   * The number of spaces to use for tab indentation.\n   * @default 4\n   */\n  tabSize: number | null | undefined\n  /**\n   * Custom HTML attributes that should be added to the rendered HTML tag.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    codeBlock: {\n      /**\n       * Set a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.setCodeBlock({ language: 'javascript' })\n       */\n      setCodeBlock: (attributes?: { language: string }) => ReturnType\n      /**\n       * Toggle a code block\n       * @param attributes Code block attributes\n       * @example editor.commands.toggleCodeBlock({ language: 'javascript' })\n       */\n      toggleCodeBlock: (attributes?: { language: string }) => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a code block with backticks.\n */\nexport const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/\n\n/**\n * Matches a code block with tildes.\n */\nexport const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/\n\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nexport const CodeBlock = Node.create<CodeBlockOptions>({\n  name: 'codeBlock',\n\n  addOptions() {\n    return {\n      languageClassPrefix: 'language-',\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      defaultLanguage: null,\n      enableTabIndentation: false,\n      tabSize: DEFAULT_TAB_SIZE,\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'text*',\n\n  marks: '',\n\n  group: 'block',\n\n  code: true,\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      language: {\n        default: this.options.defaultLanguage,\n        parseHTML: element => {\n          const { languageClassPrefix } = this.options\n\n          if (!languageClassPrefix) {\n            return null\n          }\n\n          const classNames = [...(element.firstElementChild?.classList || [])]\n          const languages = classNames\n            .filter(className => className.startsWith(languageClassPrefix))\n            .map(className => className.replace(languageClassPrefix, ''))\n          const language = languages[0]\n\n          if (!language) {\n            return null\n          }\n\n          return language\n        },\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'pre',\n        preserveWhitespace: 'full',\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'pre',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        'code',\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null,\n        },\n        0,\n      ],\n    ]\n  },\n\n  markdownTokenName: 'code',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.raw?.startsWith('```') === false && token.codeBlockStyle !== 'indented') {\n      return []\n    }\n\n    return helpers.createNode(\n      'codeBlock',\n      { language: token.lang || null },\n      token.text ? [helpers.createTextNode(token.text)] : [],\n    )\n  },\n\n  renderMarkdown: (node, h) => {\n    let output = ''\n    const language = node.attrs?.language || ''\n\n    if (!node.content) {\n      output = `\\`\\`\\`${language}\\n\\n\\`\\`\\``\n    } else {\n      const lines = [`\\`\\`\\`${language}`, h.renderChildren(node.content), '```']\n      output = lines.join('\\n')\n    }\n\n    return output\n  },\n\n  addCommands() {\n    return {\n      setCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.setNode(this.name, attributes)\n        },\n      toggleCodeBlock:\n        attributes =>\n        ({ commands }) => {\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n\n      // remove code block when at start of document or code block is empty\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection\n        const isAtStart = $anchor.pos === 1\n\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false\n        }\n\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes()\n        }\n\n        return false\n      },\n\n      // handle tab indentation\n      Tab: ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        const indent = ' '.repeat(tabSize)\n\n        if (empty) {\n          return editor.commands.insertContent(indent)\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const indentedText = lines.map(line => indent + line).join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(indentedText))\n          return true\n        })\n      },\n\n      // handle shift+tab reverse indentation\n      'Shift-Tab': ({ editor }) => {\n        if (!this.options.enableTabIndentation) {\n          return false\n        }\n\n        const tabSize = this.options.tabSize ?? DEFAULT_TAB_SIZE\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if ($from.parent.type !== this.type) {\n          return false\n        }\n\n        if (empty) {\n          return editor.commands.command(({ tr }) => {\n            const { pos } = $from\n            const codeBlockStart = $from.start()\n            const codeBlockEnd = $from.end()\n\n            const allText = state.doc.textBetween(codeBlockStart, codeBlockEnd, '\\n', '\\n')\n            const lines = allText.split('\\n')\n\n            let currentLineIndex = 0\n            let charCount = 0\n            const relativeCursorPos = pos - codeBlockStart\n\n            for (let i = 0; i < lines.length; i += 1) {\n              if (charCount + lines[i].length >= relativeCursorPos) {\n                currentLineIndex = i\n                break\n              }\n              charCount += lines[i].length + 1\n            }\n\n            const currentLine = lines[currentLineIndex]\n            const leadingSpaces = currentLine.match(/^ */)?.[0] || ''\n            const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n\n            if (spacesToRemove === 0) {\n              return true\n            }\n\n            let lineStartPos = codeBlockStart\n            for (let i = 0; i < currentLineIndex; i += 1) {\n              lineStartPos += lines[i].length + 1\n            }\n\n            tr.delete(lineStartPos, lineStartPos + spacesToRemove)\n\n            const cursorPosInLine = pos - lineStartPos\n            if (cursorPosInLine <= spacesToRemove) {\n              tr.setSelection(TextSelection.create(tr.doc, lineStartPos))\n            }\n\n            return true\n          })\n        }\n\n        return editor.commands.command(({ tr }) => {\n          const { from, to } = selection\n          const text = state.doc.textBetween(from, to, '\\n', '\\n')\n          const lines = text.split('\\n')\n          const reverseIndentText = lines\n            .map(line => {\n              const leadingSpaces = line.match(/^ */)?.[0] || ''\n              const spacesToRemove = Math.min(leadingSpaces.length, tabSize)\n              return line.slice(spacesToRemove)\n            })\n            .join('\\n')\n\n          tr.replaceWith(from, to, state.schema.text(reverseIndentText))\n          return true\n        })\n      },\n\n      // exit node on triple enter\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n')\n\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false\n        }\n\n        return editor\n          .chain()\n          .command(({ tr }) => {\n            tr.delete($from.pos - 2, $from.pos)\n\n            return true\n          })\n          .exitCode()\n          .run()\n      },\n\n      // exit node on arrow down\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false\n        }\n\n        const { state } = editor\n        const { selection, doc } = state\n        const { $from, empty } = selection\n\n        if (!empty || $from.parent.type !== this.type) {\n          return false\n        }\n\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2\n\n        if (!isAtEnd) {\n          return false\n        }\n\n        const after = $from.after()\n\n        if (after === undefined) {\n          return false\n        }\n\n        const nodeAfter = doc.nodeAt(after)\n\n        if (nodeAfter) {\n          return editor.commands.command(({ tr }) => {\n            tr.setSelection(Selection.near(doc.resolve(after)))\n            return true\n          })\n        }\n\n        return editor.commands.exitCode()\n      },\n    }\n  },\n\n  addInputRules() {\n    return [\n      textblockTypeInputRule({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n      textblockTypeInputRule({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          language: match[1],\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // this plugin creates a code block for pasted content from VS Code\n      // we can also detect the copied code language\n      new Plugin({\n        key: new PluginKey('codeBlockVSCodeHandler'),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false\n            }\n\n            // dont create a new code block within code blocks\n            if (this.editor.isActive(this.type.name)) {\n              return false\n            }\n\n            const text = event.clipboardData.getData('text/plain')\n            const vscode = event.clipboardData.getData('vscode-editor-data')\n            const vscodeData = vscode ? JSON.parse(vscode) : undefined\n            const language = vscodeData?.mode\n\n            if (!text || !language) {\n              return false\n            }\n\n            const { tr, schema } = view.state\n\n            // prepare a text node\n            // strip carriage return chars from text pasted as code\n            // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n            const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'))\n\n            // create a code block with the text node\n            // replace selection with the code block\n            tr.replaceSelectionWith(this.type.create({ language }, textNode))\n\n            if (tr.selection.$from.parent.type !== this.type) {\n              // put cursor inside the newly created code block\n              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))))\n            }\n\n            // store meta information\n            // this is useful for other plugins that depends on the paste event\n            // like the paste rule plugin\n            tr.setMeta('paste', true)\n\n            view.dispatch(tr)\n\n            return true\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Node } from '@tiptap/core'\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */\nexport const Document = Node.create({\n  name: 'doc',\n  topNode: true,\n  content: 'block+',\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n\\n')\n  },\n})\n","import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface HardBreakOptions {\n  /**\n   * Controls if marks should be kept after being split by a hard break.\n   * @default true\n   * @example false\n   */\n  keepMarks: boolean\n\n  /**\n   * HTML attributes to add to the hard break element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    hardBreak: {\n      /**\n       * Add a hard break\n       * @example editor.commands.setHardBreak()\n       */\n      setHardBreak: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */\nexport const HardBreak = Node.create<HardBreakOptions>({\n  name: 'hardBreak',\n\n  markdownTokenName: 'br',\n\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {},\n    }\n  },\n\n  inline: true,\n\n  group: 'inline',\n\n  selectable: false,\n\n  linebreakReplacement: true,\n\n  parseHTML() {\n    return [{ tag: 'br' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  renderText() {\n    return '\\n'\n  },\n\n  renderMarkdown: () => `  \\n`,\n\n  parseMarkdown: () => {\n    return {\n      type: 'hardBreak',\n    }\n  },\n\n  addCommands() {\n    return {\n      setHardBreak:\n        () =>\n        ({ commands, chain, state, editor }) => {\n          return commands.first([\n            () => commands.exitCode(),\n            () =>\n              commands.command(() => {\n                const { selection, storedMarks } = state\n\n                if (selection.$from.parent.type.spec.isolating) {\n                  return false\n                }\n\n                const { keepMarks } = this.options\n                const { splittableMarks } = editor.extensionManager\n                const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n                return chain()\n                  .insertContent({ type: this.name })\n                  .command(({ tr, dispatch }) => {\n                    if (dispatch && marks && keepMarks) {\n                      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n                      tr.ensureMarks(filteredMarks)\n                    }\n\n                    return true\n                  })\n                  .run()\n              }),\n          ])\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Enter': () => this.editor.commands.setHardBreak(),\n      'Shift-Enter': () => this.editor.commands.setHardBreak(),\n    }\n  },\n})\n","import { mergeAttributes, Node, textblockTypeInputRule } from '@tiptap/core'\n\n/**\n * The heading level options.\n */\nexport type Level = 1 | 2 | 3 | 4 | 5 | 6\n\nexport interface HeadingOptions {\n  /**\n   * The available heading levels.\n   * @default [1, 2, 3, 4, 5, 6]\n   * @example [1, 2, 3]\n   */\n  levels: Level[]\n\n  /**\n   * The HTML attributes for a heading node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    heading: {\n      /**\n       * Set a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.setHeading({ level: 1 })\n       */\n      setHeading: (attributes: { level: Level }) => ReturnType\n      /**\n       * Toggle a heading node\n       * @param attributes The heading attributes\n       * @example editor.commands.toggleHeading({ level: 1 })\n       */\n      toggleHeading: (attributes: { level: Level }) => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */\nexport const Heading = Node.create<HeadingOptions>({\n  name: 'heading',\n\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {},\n    }\n  },\n\n  content: 'inline*',\n\n  group: 'block',\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false,\n      },\n    }\n  },\n\n  parseHTML() {\n    return this.options.levels.map((level: Level) => ({\n      tag: `h${level}`,\n      attrs: { level },\n    }))\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level)\n    const level = hasLevel ? node.attrs.level : this.options.levels[0]\n\n    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'heading' token to heading node\n    // marked provides 'depth' property (1-6) for heading level\n    return helpers.createNode('heading', { level: token.depth || 1 }, helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    const level = node.attrs?.level ? parseInt(node.attrs.level as string, 10) : 1\n    const headingChars = '#'.repeat(level)\n\n    if (!node.content) {\n      return ''\n    }\n\n    // Use current context for proper joining/spacing\n    return `${headingChars} ${h.renderChildren(node.content)}`\n  },\n\n  addCommands() {\n    return {\n      setHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.setNode(this.name, attributes)\n        },\n      toggleHeading:\n        attributes =>\n        ({ commands }) => {\n          if (!this.options.levels.includes(attributes.level)) {\n            return false\n          }\n\n          return commands.toggleNode(this.name, 'paragraph', attributes)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce(\n      (items, level) => ({\n        ...items,\n        ...{\n          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n        },\n      }),\n      {},\n    )\n  },\n\n  addInputRules() {\n    return this.options.levels.map(level => {\n      return textblockTypeInputRule({\n        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level,\n        },\n      })\n    })\n  },\n})\n","import { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  /**\n   * The HTML attributes for a horizontal rule node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n  /**\n   * The default type to insert after the horizontal rule.\n   * @default \"paragraph\"\n   * @example \"heading\"\n   */\n  nextNodeType: string\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       * @example editor.commands.setHorizontalRule()\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      nextNodeType: 'paragraph',\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  markdownTokenName: 'hr',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.createNode('horizontalRule')\n  },\n\n  renderMarkdown: () => {\n    return '---'\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () =>\n        ({ chain, state }) => {\n          // Check if we can insert the node at the current selection\n          if (!canInsertNode(state, state.schema.nodes[this.name])) {\n            return false\n          }\n\n          const { selection } = state\n          const { $to: $originTo } = selection\n\n          const currentChain = chain()\n\n          if (isNodeSelection(selection)) {\n            currentChain.insertContentAt($originTo.pos, {\n              type: this.name,\n            })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ state: chainState, tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if its the end of the document\n                    const nodeType =\n                      chainState.schema.nodes[this.options.nextNodeType] || $to.parent.type.contentMatch.defaultType\n                    const node = nodeType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface ItalicOptions {\n  /**\n   * HTML attributes to add to the italic element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    italic: {\n      /**\n       * Set an italic mark\n       * @example editor.commands.setItalic()\n       */\n      setItalic: () => ReturnType\n      /**\n       * Toggle an italic mark\n       * @example editor.commands.toggleItalic()\n       */\n      toggleItalic: () => ReturnType\n      /**\n       * Unset an italic mark\n       * @example editor.commands.unsetItalic()\n       */\n      unsetItalic: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an italic to a *italic* on input.\n */\nexport const starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/\n\n/**\n * Matches an italic to a *italic* on paste.\n */\nexport const starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g\n\n/**\n * Matches an italic to a _italic_ on input.\n */\nexport const underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/\n\n/**\n * Matches an italic to a _italic_ on paste.\n */\nexport const underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g\n\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */\nexport const Italic = Mark.create<ItalicOptions>({\n  name: 'italic',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'em',\n      },\n      {\n        tag: 'i',\n        getAttrs: node => (node as HTMLElement).style.fontStyle !== 'normal' && null,\n      },\n      {\n        style: 'font-style=normal',\n        clearMark: mark => mark.type.name === this.name,\n      },\n      {\n        style: 'font-style=italic',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setItalic:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleItalic:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetItalic:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  markdownTokenName: 'em',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'em' token to italic mark\n    return helpers.applyMark('italic', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `*${h.renderChildren(node)}*`\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-i': () => this.editor.commands.toggleItalic(),\n      'Mod-I': () => this.editor.commands.toggleItalic(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: starInputRegex,\n        type: this.type,\n      }),\n      markInputRule({\n        find: underscoreInputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: starPasteRegex,\n        type: this.type,\n      }),\n      markPasteRule({\n        find: underscorePasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = 'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = '121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222';\n\n/**\n * Finite State Machine generation utilities\n */\n\n/**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */\n\n/**\n * @typedef {{ [group: string]: true }} Flags\n */\n\n// Keys in scanner Collections instances\nconst numeric = 'numeric';\nconst ascii = 'ascii';\nconst alpha = 'alpha';\nconst asciinumeric = 'asciinumeric';\nconst alphanumeric = 'alphanumeric';\nconst domain = 'domain';\nconst emoji = 'emoji';\nconst scheme = 'scheme';\nconst slashscheme = 'slashscheme';\nconst whitespace = 'whitespace';\n\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (const k in flags) {\n    const group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */\nfunction flagsForToken(t, groups) {\n  const result = {};\n  for (const c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\n * @template T\n * @typedef {null | T } Transition\n */\n\n/**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */\nfunction State(token = null) {\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\n * Scanner token groups\n * @type Collections<string>\n */\nState.groups = {};\nState.prototype = {\n  accepts() {\n    return !!this.t;\n  },\n  /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */\n  go(input) {\n    const state = this;\n    const nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (let i = 0; i < state.jr.length; i++) {\n      const regex = state.jr[i][0];\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (nextState && regex.test(input)) {\n        return nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */\n  has(input, exactOnly = false) {\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */\n  ta(inputs, next, flags, groups) {\n    for (let i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    let nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  ts(input, next, flags, groups) {\n    let state = this;\n    const len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (let i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */\n  tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    const state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    const t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    let nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      Object.assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\n\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/\n\n// A valid web domain token\nconst WORD = 'WORD'; // only contains a-z\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\nconst ASCIINUMERICAL = 'ASCIINUMERICAL'; // contains a-z, 0-9\nconst ALPHANUMERICAL = 'ALPHANUMERICAL'; // contains numbers and letters other than a-z, used for IDN\n\n// Special case of word\nconst LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nconst NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nconst WS = 'WS';\n\n// New line (unix style)\nconst NL = 'NL'; // \\n\n\n// Opening/closing bracket classes\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\n// Also rename angle brackes to LESSTHAN and GREATER THAN\nconst OPENBRACE = 'OPENBRACE'; // {\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\nconst OPENBRACKET = 'OPENBRACKET'; // [\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nconst OPENPAREN = 'OPENPAREN'; // (\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nconst FULLWIDTHLEFTPAREN = 'FULLWIDTHLEFTPAREN'; // \nconst FULLWIDTHRIGHTPAREN = 'FULLWIDTHRIGHTPAREN'; // \nconst LEFTCORNERBRACKET = 'LEFTCORNERBRACKET'; // \nconst RIGHTCORNERBRACKET = 'RIGHTCORNERBRACKET'; // \nconst LEFTWHITECORNERBRACKET = 'LEFTWHITECORNERBRACKET'; // \nconst RIGHTWHITECORNERBRACKET = 'RIGHTWHITECORNERBRACKET'; // \nconst FULLWIDTHLESSTHAN = 'FULLWIDTHLESSTHAN'; // \nconst FULLWIDTHGREATERTHAN = 'FULLWIDTHGREATERTHAN'; // \n\n// Various symbols\nconst AMPERSAND = 'AMPERSAND'; // &\nconst APOSTROPHE = 'APOSTROPHE'; // '\nconst ASTERISK = 'ASTERISK'; // *\nconst AT = 'AT'; // @\nconst BACKSLASH = 'BACKSLASH'; // \\\nconst BACKTICK = 'BACKTICK'; // `\nconst CARET = 'CARET'; // ^\nconst COLON = 'COLON'; // :\nconst COMMA = 'COMMA'; // ,\nconst DOLLAR = 'DOLLAR'; // $\nconst DOT = 'DOT'; // .\nconst EQUALS = 'EQUALS'; // =\nconst EXCLAMATION = 'EXCLAMATION'; // !\nconst HYPHEN = 'HYPHEN'; // -\nconst PERCENT = 'PERCENT'; // %\nconst PIPE = 'PIPE'; // |\nconst PLUS = 'PLUS'; // +\nconst POUND = 'POUND'; // #\nconst QUERY = 'QUERY'; // ?\nconst QUOTE = 'QUOTE'; // \"\nconst FULLWIDTHMIDDLEDOT = 'FULLWIDTHMIDDLEDOT'; // \n\nconst SEMI = 'SEMI'; // ;\nconst SLASH = 'SLASH'; // /\nconst TILDE = 'TILDE'; // ~\nconst UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nconst EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nconst SYM = 'SYM';\n\nvar tk = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tALPHANUMERICAL: ALPHANUMERICAL,\n\tAMPERSAND: AMPERSAND,\n\tAPOSTROPHE: APOSTROPHE,\n\tASCIINUMERICAL: ASCIINUMERICAL,\n\tASTERISK: ASTERISK,\n\tAT: AT,\n\tBACKSLASH: BACKSLASH,\n\tBACKTICK: BACKTICK,\n\tCARET: CARET,\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n\tCLOSEBRACE: CLOSEBRACE,\n\tCLOSEBRACKET: CLOSEBRACKET,\n\tCLOSEPAREN: CLOSEPAREN,\n\tCOLON: COLON,\n\tCOMMA: COMMA,\n\tDOLLAR: DOLLAR,\n\tDOT: DOT,\n\tEMOJI: EMOJI$1,\n\tEQUALS: EQUALS,\n\tEXCLAMATION: EXCLAMATION,\n\tFULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\n\tFULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\n\tFULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\n\tFULLWIDTHMIDDLEDOT: FULLWIDTHMIDDLEDOT,\n\tFULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\n\tHYPHEN: HYPHEN,\n\tLEFTCORNERBRACKET: LEFTCORNERBRACKET,\n\tLEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\n\tLOCALHOST: LOCALHOST,\n\tNL: NL,\n\tNUM: NUM,\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\n\tOPENBRACE: OPENBRACE,\n\tOPENBRACKET: OPENBRACKET,\n\tOPENPAREN: OPENPAREN,\n\tPERCENT: PERCENT,\n\tPIPE: PIPE,\n\tPLUS: PLUS,\n\tPOUND: POUND,\n\tQUERY: QUERY,\n\tQUOTE: QUOTE,\n\tRIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\n\tRIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\n\tSCHEME: SCHEME,\n\tSEMI: SEMI,\n\tSLASH: SLASH,\n\tSLASH_SCHEME: SLASH_SCHEME,\n\tSYM: SYM,\n\tTILDE: TILDE,\n\tTLD: TLD,\n\tUNDERSCORE: UNDERSCORE,\n\tUTLD: UTLD,\n\tUWORD: UWORD,\n\tWORD: WORD,\n\tWS: WS\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\n\nvar regexp = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tASCII_LETTER: ASCII_LETTER,\n\tDIGIT: DIGIT,\n\tEMOJI: EMOJI,\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\n\tLETTER: LETTER,\n\tSPACE: SPACE\n});\n\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/\n\nconst CR = '\\r'; // carriage-return character\nconst LF = '\\n'; // line-feed character\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\nconst OBJECT_REPLACEMENT = '\\ufffc'; // whitespace placeholder that sometimes appears in rich text editors\n\nlet tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */\n\n/**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */\n\n/**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */\nfunction init$2(customSchemes = []) {\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  const groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  const Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, '', FULLWIDTHLEFTPAREN);\n  tt(Start, '', FULLWIDTHRIGHTPAREN);\n  tt(Start, '', LEFTCORNERBRACKET);\n  tt(Start, '', RIGHTCORNERBRACKET);\n  tt(Start, '', LEFTWHITECORNERBRACKET);\n  tt(Start, '', RIGHTWHITECORNERBRACKET);\n  tt(Start, '', FULLWIDTHLESSTHAN);\n  tt(Start, '', FULLWIDTHGREATERTHAN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  tt(Start, '', FULLWIDTHMIDDLEDOT);\n  const Num = tr(Start, DIGIT, NUM, {\n    [numeric]: true\n  });\n  tr(Num, DIGIT, Num);\n  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {\n    [asciinumeric]: true\n  });\n  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {\n    [alphanumeric]: true\n  });\n\n  // State which emits a word token\n  const Word = tr(Start, ASCII_LETTER, WORD, {\n    [ascii]: true\n  });\n  tr(Word, DIGIT, Asciinumeric);\n  tr(Word, ASCII_LETTER, Word);\n  tr(Asciinumeric, DIGIT, Asciinumeric);\n  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  const UWord = tr(Start, LETTER, UWORD, {\n    [alpha]: true\n  });\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, DIGIT, Alphanumeric);\n  tr(UWord, LETTER, UWord);\n  tr(Alphanumeric, DIGIT, Alphanumeric);\n  tr(Alphanumeric, ASCII_LETTER); // Non-accepting\n  tr(Alphanumeric, LETTER, Alphanumeric); // Non-accepting\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  const Nl = tt(Start, LF, NL, {\n    [whitespace]: true\n  });\n  const Cr = tt(Start, CR, WS, {\n    [whitespace]: true\n  });\n  const Ws = tr(Start, SPACE, WS, {\n    [whitespace]: true\n  });\n  tt(Start, OBJECT_REPLACEMENT, Ws);\n  tt(Cr, LF, Nl); // \\r\\n\n  tt(Cr, OBJECT_REPLACEMENT, Ws);\n  tr(Cr, SPACE, Ws);\n  tt(Ws, CR); // non-accepting state to avoid mixing whitespaces\n  tt(Ws, LF); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n  tt(Ws, OBJECT_REPLACEMENT, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\n    [emoji]: true\n  });\n  tt(Emoji, '#'); // no transition, emoji regex seems to match #\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tt(EmojiJoiner, '#');\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];\n  for (let i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (let i = 0; i < utlds.length; i++) {\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  for (let i = 0; i < customSchemes.length; i++) {\n    const sch = customSchemes[i][0];\n    const optionalSlashSlash = customSchemes[i][1];\n    const flags = optionalSlashSlash ? {\n      [scheme]: true\n    } : {\n      [slashscheme]: true\n    };\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: Object.assign({\n      groups\n    }, tk)\n  };\n}\n\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\n  const charCount = iterable.length; // <= len if there are emojis, etc\n  const tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  let cursor = 0;\n\n  // Cursor through the array-representation of the string\n  let charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    let state = start;\n    let nextState = null;\n    let tokenLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    let charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n  return tokens;\n}\n\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */\nfunction stringToArray(str) {\n  const result = [];\n  const len = str.length;\n  let index = 0;\n  while (index < len) {\n    let first = str.charCodeAt(index);\n    let second;\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(char);\n    index += char.length;\n  }\n  return result;\n}\n\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  let next;\n  const len = input.length;\n  for (let i = 0; i < len - 1; i++) {\n    const char = input[i];\n    if (state.j[char]) {\n      next = state.j[char];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[char] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */\nfunction decodeTlds(encoded) {\n  const words = [];\n  const stack = [];\n  let i = 0;\n  let digits = '0123456789';\n  while (i < encoded.length) {\n    let popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */\n\n/**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */\n\n/**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */\n\n/**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */\n\n/**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */\n\n/**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */\n\n/**\n * @type Required<Opts>\n */\nconst defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */\nfunction Options(opts, defaultRender = null) {\n  let o = Object.assign({}, defaults);\n  if (opts) {\n    o = Object.assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  const ignoredTags = o.ignoreTags;\n  const uppercaseIgnoredTags = [];\n  for (let i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\n   * @type string[]\n   */\n  ignoreTags: [],\n  /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */\n  defaultRender(ir) {\n    return ir;\n  },\n  /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */\n  check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n\n  /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */\n  get(key, operator, token) {\n    const isCallable = operator != null;\n    let option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (typeof option === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */\n  getObj(key, operator, token) {\n    let obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */\n  render(token) {\n    const ir = token.render(this); // intermediate representation\n    const renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\n\nvar options = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tOptions: Options,\n\tdefaults: defaults\n});\n\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/\n\n/**\n * @param {string} value\n * @param {Token[]} tokens\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\n   * Return the string this token represents.\n   * @return {string}\n   */\n  toString() {\n    return this.v;\n  },\n  /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n   */\n  toHref(scheme) {\n    return this.toString();\n  },\n  /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */\n  toFormattedString(options) {\n    const val = this.toString();\n    const truncate = options.get('truncate', val, this);\n    const formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '' : formatted;\n  },\n  /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */\n  toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */\n  startIndex() {\n    return this.tk[0].s;\n  },\n  /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */\n  endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */\n  toObject(protocol = defaults.defaultProtocol) {\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   *\n   * @param {Options} options Formatting option\n   */\n  toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */\n  validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */\n  render(options) {\n    const token = this;\n    const href = this.toHref(options.get('defaultProtocol'));\n    const formattedHref = options.get('formatHref', href, this);\n    const tagName = options.get('tagName', href, token);\n    const content = this.toFormattedString(options);\n    const attributes = {};\n    const className = options.get('className', href, token);\n    const target = options.get('target', href, token);\n    const rel = options.get('rel', href, token);\n    const attrs = options.getObj('attributes', href, token);\n    const eventListeners = options.getObj('events', href, token);\n    attributes.href = formattedHref;\n    if (className) {\n      attributes.class = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      Object.assign(attributes, attrs);\n    }\n    return {\n      tagName,\n      attributes,\n      content,\n      eventListeners\n    };\n  }\n};\n\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */\nfunction createTokenClass(type, props) {\n  class Token extends MultiToken {\n    constructor(value, tokens) {\n      super(value, tokens);\n      this.t = type;\n    }\n  }\n  for (const p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\n\tRepresents a list of tokens making up a valid email address\n*/\nconst Email = createTokenClass('email', {\n  isLink: true,\n  toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\n\tRepresents some plain text\n*/\nconst Text = createTokenClass('text');\n\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/\nconst Nl = createTokenClass('nl');\n\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/\nconst Url = createTokenClass('url', {\n  isLink: true,\n  /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */\n  toHref(scheme = defaults.defaultProtocol) {\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n  },\n  /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */\n  hasProtocol() {\n    const tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\n\nvar multi = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBase: MultiToken,\n\tEmail: Email,\n\tMultiToken: MultiToken,\n\tNl: Nl,\n\tText: Text,\n\tUrl: Url,\n\tcreateTokenClass: createTokenClass\n});\n\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/\n\nconst makeState = arg => new State(arg);\n\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */\nfunction init$1({\n  groups\n}) {\n  // Types of characters the URL can definitely end in\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\n   * @type State<Token>\n   */\n  const Start = makeState();\n  const Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  const Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  const EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\n  tt(DomainHyphen, HYPHEN, DomainHyphen);\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  const Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(SchemeColon, groups.domain, Url$1);\n  tt(SchemeColon, SLASH, Url$1);\n  tt(SchemeColon, QUERY, Url$1);\n  ta(UriPrefix, groups.domain, Url$1);\n  ta(UriPrefix, qsAccepting, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n  const bracketPairs = [[OPENBRACE, CLOSEBRACE],\n  // {}\n  [OPENBRACKET, CLOSEBRACKET],\n  // []\n  [OPENPAREN, CLOSEPAREN],\n  // ()\n  [OPENANGLEBRACKET, CLOSEANGLEBRACKET],\n  // <>\n  [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],\n  // \n  [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],\n  // \n  [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],\n  // \n  [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN] // \n  ];\n  for (let i = 0; i < bracketPairs.length; i++) {\n    const [OPEN, CLOSE] = bracketPairs[i];\n    const UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\n\n    // Continue not accepting for open brackets\n    tt(UrlNonaccept, OPEN, UrlOpen);\n\n    // Closing bracket component. This character WILL be included in the URL\n    tt(UrlOpen, CLOSE, Url$1);\n\n    // URL that beings with an opening bracket, followed by a symbols.\n    // Note that the final state can still be `UrlOpen` (if the URL has a\n    // single opening bracket for some reason).\n    const UrlOpenQ = makeState(Url);\n    ta(UrlOpen, qsAccepting, UrlOpenQ);\n    const UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\n    ta(UrlOpen, qsNonAccepting);\n\n    // URL that begins with an opening bracket, followed by some symbols\n    ta(UrlOpenQ, qsAccepting, UrlOpenQ);\n    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\n    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\n    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\n\n    // Close brace/bracket to become regular URL\n    tt(UrlOpenQ, CLOSE, Url$1);\n    tt(UrlOpenSyms, CLOSE, Url$1);\n  }\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */\nfunction run(start, input, tokens) {\n  let len = tokens.length;\n  let cursor = 0;\n  let multis = [];\n  let textTokens = [];\n  while (cursor < len) {\n    let state = start;\n    let secondState = null;\n    let nextState = null;\n    let multiLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      const Multi = latestAccepting.t;\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */\nfunction initMultiToken(Multi, input, tokens) {\n  const startIdx = tokens[0].s;\n  const endIdx = tokens[tokens.length - 1].e;\n  const value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\n\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nconst INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */\n\n/**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */\n\n/**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */\nfunction reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n  return INIT;\n}\n\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} scheme\n * @param {boolean} [optionalSlashSlash]\n */\nfunction registerCustomProtocol(scheme, optionalSlashSlash = false) {\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error(`linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or \"-\"\n2. Cannot start or end with \"-\"\n3. \"-\" cannot repeat`);\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    INIT.pluginQueue[i][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n  return INIT;\n}\n\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\ntokenize.scan = run$1; // for testing\n\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n */\nfunction find(str, type = null, opts = null) {\n  if (type && typeof type === 'object') {\n    if (opts) {\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n    }\n    opts = type;\n    type = null;\n  }\n  const options = new Options(opts);\n  const tokens = tokenize(str);\n  const filtered = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.isLink && (!type || token.t === type) && options.check(token)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */\nfunction test(str, type = null) {\n  const tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, multi as text, tokenize };\n","// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.ts\nexport const UNICODE_WHITESPACE_PATTERN = '[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]'\n\nexport const UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN)\nexport const UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`)\nexport const UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, 'g')\n","import type { PasteRuleMatch } from '@tiptap/core'\nimport { Mark, markPasteRule, mergeAttributes } from '@tiptap/core'\nimport type { Plugin } from '@tiptap/pm/state'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink.js'\nimport { clickHandler } from './helpers/clickHandler.js'\nimport { pasteHandler } from './helpers/pasteHandler.js'\nimport { UNICODE_WHITESPACE_REGEX_GLOBAL } from './helpers/whitespace.js'\n\nexport interface LinkProtocolOptions {\n  /**\n   * The protocol scheme to be registered.\n   * @default '''\n   * @example 'ftp'\n   * @example 'git'\n   */\n  scheme: string\n\n  /**\n   * If enabled, it allows optional slashes after the protocol.\n   * @default false\n   * @example true\n   */\n  optionalSlashes?: boolean\n}\n\nexport const pasteRegex =\n  /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi\n\n/**\n * @deprecated The default behavior is now to open links when the editor is not editable.\n */\ntype DeprecatedOpenWhenNotEditable = 'whenNotEditable'\n\nexport interface LinkOptions {\n  /**\n   * If enabled, the extension will automatically add links as you type.\n   * @default true\n   * @example false\n   */\n  autolink: boolean\n\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   * @default []\n   * @example ['ftp', 'git']\n   */\n  protocols: Array<LinkProtocolOptions | string>\n\n  /**\n   * Default protocol to use when no protocol is specified.\n   * @default 'http'\n   */\n  defaultProtocol: string\n  /**\n   * If enabled, links will be opened on click.\n   * @default true\n   * @example false\n   */\n  openOnClick: boolean | DeprecatedOpenWhenNotEditable\n  /**\n   * If enabled, the link will be selected when clicked.\n   * @default false\n   * @example true\n   */\n  enableClickSelection: boolean\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   * @default true\n   * @example false\n   */\n  linkOnPaste: boolean\n\n  /**\n   * HTML attributes to add to the link element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * @deprecated Use the `shouldAutoLink` option instead.\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate: (url: string) => boolean\n\n  /**\n   * A validation function which is used for configuring link verification for preventing XSS attacks.\n   * Only modify this if you know what you're doing.\n   *\n   * @returns {boolean} `true` if the URL is valid, `false` otherwise.\n   *\n   * @example\n   * isAllowedUri: (url, { defaultValidate, protocols, defaultProtocol }) => {\n   * return url.startsWith('./') || defaultValidate(url)\n   * }\n   */\n  isAllowedUri: (\n    /**\n     * The URL to be validated.\n     */\n    url: string,\n    ctx: {\n      /**\n       * The default validation function.\n       */\n      defaultValidate: (url: string) => boolean\n      /**\n       * An array of allowed protocols for the URL (e.g., \"http\", \"https\"). As defined in the `protocols` option.\n       */\n      protocols: Array<LinkProtocolOptions | string>\n      /**\n       * A string that represents the default protocol (e.g., 'http'). As defined in the `defaultProtocol` option.\n       */\n      defaultProtocol: string\n    },\n  ) => boolean\n\n  /**\n   * Determines whether a valid link should be automatically linked in the content.\n   *\n   * @param {string} url - The URL that has already been validated.\n   * @returns {boolean} - True if the link should be auto-linked; false if it should not be auto-linked.\n   */\n  shouldAutoLink: (url: string) => boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.setLink({ href: 'https://tiptap.dev' })\n       */\n      setLink: (attributes: {\n        href: string\n        target?: string | null\n        rel?: string | null\n        class?: string | null\n        title?: string | null\n      }) => ReturnType\n      /**\n       * Toggle a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.toggleLink({ href: 'https://tiptap.dev' })\n       */\n      toggleLink: (attributes?: {\n        href: string\n        target?: string | null\n        rel?: string | null\n        class?: string | null\n        title?: string | null\n      }) => ReturnType\n      /**\n       * Unset a link mark\n       * @example editor.commands.unsetLink()\n       */\n      unsetLink: () => ReturnType\n    }\n  }\n}\n\nexport function isAllowedUri(uri: string | undefined, protocols?: LinkOptions['protocols']) {\n  const allowedProtocols: string[] = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp']\n\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme\n\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol)\n      }\n    })\n  }\n\n  return (\n    !uri ||\n    uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, '').match(\n      new RegExp(\n        // eslint-disable-next-line no-useless-escape\n        `^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`,\n        'i',\n      ),\n    )\n  )\n}\n\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  exitable: true,\n\n  onCreate() {\n    // TODO: v4 - remove validate option\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      // Copy the validate function to the shouldAutoLink option\n      this.options.shouldAutoLink = this.options.validate\n      console.warn('The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.')\n    }\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol)\n        return\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes)\n    })\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      enableClickSelection: false,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: url => !!url,\n      shouldAutoLink: url => {\n        // URLs with explicit protocols (e.g., https://) should be auto-linked\n        // But not if @ appears before :// (that would be userinfo like user:pass@host)\n        const hasProtocol = /^[a-z][a-z0-9+.-]*:\\/\\//i.test(url)\n        const hasMaybeProtocol = /^[a-z][a-z0-9+.-]*:/i.test(url)\n\n        if (hasProtocol || (hasMaybeProtocol && !url.includes('@'))) {\n          return true\n        }\n        // Strip userinfo (user:pass@) if present, then extract hostname\n        const urlWithoutUserinfo = url.includes('@') ? url.split('@').pop()! : url\n        const hostname = urlWithoutUserinfo.split(/[/?#:]/)[0]\n\n        // Don't auto-link IP addresses without protocol\n        if (/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(hostname)) {\n          return false\n        }\n        // Don't auto-link single-word hostnames without TLD (e.g., \"localhost\")\n        if (!/\\./.test(hostname)) {\n          return false\n        }\n        return true\n      },\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href')\n        },\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n      title: {\n        default: null,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'a[href]',\n        getAttrs: dom => {\n          const href = (dom as HTMLElement).getAttribute('href')\n\n          // prevent XSS attacks\n          if (\n            !href ||\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n          return null\n        },\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    // prevent XSS attacks\n    if (\n      !this.options.isAllowedUri(HTMLAttributes.href, {\n        defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n        protocols: this.options.protocols,\n        defaultProtocol: this.options.defaultProtocol,\n      })\n    ) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }), 0]\n    }\n\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'link',\n\n  parseMarkdown: (token, helpers) => {\n    return helpers.applyMark('link', helpers.parseInline(token.tokens || []), {\n      href: token.href,\n      title: token.title || null,\n    })\n  },\n\n  renderMarkdown: (node, h) => {\n    const href = node.attrs?.href ?? ''\n    const title = node.attrs?.title ?? ''\n    const text = h.renderChildren(node)\n\n    return title ? `[${text}](${href} \"${title}\")` : `[${text}](${href})`\n  },\n\n  addCommands() {\n    return {\n      setLink:\n        attributes =>\n        ({ chain }) => {\n          const { href } = attributes\n\n          if (\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n\n          return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run()\n        },\n\n      toggleLink:\n        attributes =>\n        ({ chain }) => {\n          const { href } = attributes || {}\n\n          if (\n            href &&\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n\n          return chain()\n            .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n\n      unsetLink:\n        () =>\n        ({ chain }) => {\n          return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta('preventAutolink', true).run()\n        },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => {\n          const foundLinks: PasteRuleMatch[] = []\n\n          if (text) {\n            const { protocols, defaultProtocol } = this.options\n            const links = find(text).filter(\n              item =>\n                item.isLink &&\n                this.options.isAllowedUri(item.value, {\n                  defaultValidate: href => !!isAllowedUri(href, protocols),\n                  protocols,\n                  defaultProtocol,\n                }),\n            )\n\n            if (links.length) {\n              links.forEach(link => {\n                if (!this.options.shouldAutoLink(link.value)) {\n                  return\n                }\n\n                foundLinks.push({\n                  text: link.value,\n                  data: {\n                    href: link.href,\n                  },\n                  index: link.start,\n                })\n              })\n            }\n          }\n\n          return foundLinks\n        },\n        type: this.type,\n        getAttributes: match => {\n          return {\n            href: match.data?.href,\n          }\n        },\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n    const { protocols, defaultProtocol } = this.options\n\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: url =>\n            this.options.isAllowedUri(url, {\n              defaultValidate: href => !!isAllowedUri(href, protocols),\n              protocols,\n              defaultProtocol,\n            }),\n          shouldAutoLink: this.options.shouldAutoLink,\n        }),\n      )\n    }\n\n    plugins.push(\n      clickHandler({\n        type: this.type,\n        editor: this.editor,\n        openOnClick: this.options.openOnClick === 'whenNotEditable' ? true : this.options.openOnClick,\n        enableClickSelection: this.options.enableClickSelection,\n      }),\n    )\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type,\n          shouldAutoLink: this.options.shouldAutoLink,\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n","import type { NodeWithPos } from '@tiptap/core'\nimport { combineTransactionSteps, findChildrenInRange, getChangedRanges, getMarksBetween } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport type { MultiToken } from 'linkifyjs'\nimport { tokenize } from 'linkifyjs'\n\nimport { UNICODE_WHITESPACE_REGEX, UNICODE_WHITESPACE_REGEX_END } from './whitespace.js'\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens: Array<ReturnType<MultiToken['toObject']>>) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink\n  }\n\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value)\n  }\n\n  return false\n}\n\ntype AutolinkOptions = {\n  type: MarkType\n  defaultProtocol: string\n  validate: (url: string) => boolean\n  shouldAutoLink: (url: string) => boolean\n}\n\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ newRange }) => {\n        // Now lets see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock)\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (nodesInChangedRanges.length) {\n          const endText = newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ')\n          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n            return\n          }\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ')\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean)\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol))\n\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false\n          }\n\n          linksBeforeSpace\n            .filter(link => link.isLink)\n            // Calculate link position.\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // ignore link inside code mark\n            .filter(link => {\n              if (!newState.schema.marks.code) {\n                return true\n              }\n\n              return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code)\n            })\n            // validate link\n            .filter(link => options.validate(link.value))\n            // check whether should autolink\n            .filter(link => options.shouldAutoLink(link.value))\n            // Add link mark.\n            .forEach(link => {\n              if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                return\n              }\n\n              tr.addMark(\n                link.from,\n                link.to,\n                options.type.create({\n                  href: link.href,\n                }),\n              )\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","import type { Editor } from '@tiptap/core'\nimport { getAttributes } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\ntype ClickHandlerOptions = {\n  type: MarkType\n  editor: Editor\n  openOnClick?: boolean\n  enableClickSelection?: boolean\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        if (event.button !== 0) {\n          return false\n        }\n\n        if (!view.editable) {\n          return false\n        }\n\n        let link: HTMLAnchorElement | null = null\n\n        if (event.target instanceof HTMLAnchorElement) {\n          link = event.target\n        } else {\n          const target = event.target as HTMLElement | null\n          if (!target) {\n            return false\n          }\n\n          const root = options.editor.view.dom\n\n          // Tntentionally limit the lookup to the editor root.\n          // Using tag names like DIV as boundaries breaks with custom NodeViews,\n          link = target.closest<HTMLAnchorElement>('a')\n\n          if (link && !root.contains(link)) {\n            link = null\n          }\n        }\n\n        if (!link) {\n          return false\n        }\n\n        let handled = false\n\n        if (options.enableClickSelection) {\n          const commandResult = options.editor.commands.extendMarkRange(options.type.name)\n          handled = commandResult\n        }\n\n        if (options.openOnClick) {\n          const attrs = getAttributes(view.state, options.type.name)\n          const href = link.href ?? attrs.href\n          const target = link.target ?? attrs.target\n\n          if (href) {\n            window.open(href, target)\n            handled = true\n          }\n        }\n\n        return handled\n      },\n    },\n  })\n}\n","import type { Editor } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find } from 'linkifyjs'\n\nimport type { LinkOptions } from '../link.js'\n\ntype PasteHandlerOptions = {\n  editor: Editor\n  defaultProtocol: string\n  type: MarkType\n  shouldAutoLink?: LinkOptions['shouldAutoLink']\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, _event, slice) => {\n        const { shouldAutoLink } = options\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(\n          item => item.isLink && item.value === textContent,\n        )\n\n        if (!textContent || !link || (shouldAutoLink !== undefined && !shouldAutoLink(link.value))) {\n          return false\n        }\n\n        return options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n      },\n    },\n  })\n}\n","import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface BulletListOptions {\n  /**\n   * The node name for the list items\n   * @default 'listItem'\n   * @example 'paragraph'\n   */\n  itemTypeName: string\n\n  /**\n   * HTML attributes to add to the bullet list element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting the list\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting the list\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nexport const bulletListInputRegex = /^\\s*([-+*])\\s$/\n\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [{ tag: 'ul' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || (token as any).ordered) {\n      return []\n    }\n\n    return {\n      type: 'bulletList',\n      content: token.items ? helpers.parseChildren(token.items) : [],\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type,\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName)\n        },\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import { mergeAttributes, Node, renderNestedMarkdownContent } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  /**\n   * The HTML attributes for a list item node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for bulletList nodes\n   * @default 'bulletList'\n   * @example 'myCustomBulletList'\n   */\n  bulletListTypeName: string\n\n  /**\n   * The node type for orderedList nodes\n   * @default 'orderedList'\n   * @example 'myCustomOrderedList'\n   */\n  orderedListTypeName: string\n}\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: 'bulletList',\n      orderedListTypeName: 'orderedList',\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list_item',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list_item') {\n      return []\n    }\n\n    let content: any[] = []\n\n    if (token.tokens && token.tokens.length > 0) {\n      // Check if we have paragraph tokens (complex list items)\n      const hasParagraphTokens = token.tokens.some(t => t.type === 'paragraph')\n\n      if (hasParagraphTokens) {\n        // If we have paragraph tokens, parse them as block elements\n        content = helpers.parseChildren(token.tokens)\n      } else {\n        // Check if the first token is a text token with nested inline tokens\n        const firstToken = token.tokens[0]\n\n        if (firstToken && firstToken.type === 'text' && firstToken.tokens && firstToken.tokens.length > 0) {\n          // Parse the inline content from the text token\n          const inlineContent = helpers.parseInline(firstToken.tokens)\n\n          // Start with the paragraph containing the inline content\n          content = [\n            {\n              type: 'paragraph',\n              content: inlineContent,\n            },\n          ]\n\n          // If there are additional tokens after the first text token (like nested lists),\n          // parse them as block elements and add them\n          if (token.tokens.length > 1) {\n            const remainingTokens = token.tokens.slice(1)\n            const additionalContent = helpers.parseChildren(remainingTokens)\n            content.push(...additionalContent)\n          }\n        } else {\n          // Fallback: parse all tokens as block elements\n          content = helpers.parseChildren(token.tokens)\n        }\n      }\n    }\n\n    // Ensure we always have at least an empty paragraph\n    if (content.length === 0) {\n      content = [\n        {\n          type: 'paragraph',\n          content: [],\n        },\n      ]\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h, ctx) => {\n    return renderNestedMarkdownContent(\n      node,\n      h,\n      (context: any) => {\n        if (context.parentType === 'bulletList') {\n          return '- '\n        }\n        if (context.parentType === 'orderedList') {\n          const start = context.meta?.parentAttrs?.start || 1\n          return `${start + context.index}. `\n        }\n        // Fallback to bullet list for unknown parent types\n        return '- '\n      },\n      ctx,\n    )\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n","export * from './findListItemPos.js'\nexport * from './getNextListDepth.js'\nexport * from './handleBackspace.js'\nexport * from './handleDelete.js'\nexport * from './hasListBefore.js'\nexport * from './hasListItemAfter.js'\nexport * from './hasListItemBefore.js'\nexport * from './listItemHasSubList.js'\nexport * from './nextListIsDeeper.js'\nexport * from './nextListIsHigher.js'\n","import { getNodeType } from '@tiptap/core'\nimport type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const findListItemPos = (typeOrName: string | NodeType, state: EditorState) => {\n  const { $from } = state.selection\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let currentNode = null\n  let currentDepth = $from.depth\n  let currentPos = $from.pos\n  let targetDepth: number | null = null\n\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth)\n\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth\n    } else {\n      currentDepth -= 1\n      currentPos -= 1\n    }\n  }\n\n  if (targetDepth === null) {\n    return null\n  }\n\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth }\n}\n","import { getNodeAtPosition } from '@tiptap/core'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\n\nexport const getNextListDepth = (typeOrName: string, state: EditorState) => {\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4)\n\n  return depth\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListBefore = (editorState: EditorState, name: string, parentListTypes: string[]) => {\n  const { $anchor } = editorState.selection\n\n  const previousNodePos = Math.max(0, $anchor.pos - 2)\n\n  const previousNode = editorState.doc.resolve(previousNodePos).node()\n\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false\n  }\n\n  return true\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemBefore = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - 2)\n\n  if ($targetPos.index() === 0) {\n    return false\n  }\n\n  if ($targetPos.nodeBefore?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { getNodeType } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const listItemHasSubList = (typeOrName: string, state: EditorState, node?: Node) => {\n  if (!node) {\n    return false\n  }\n\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let hasSubList = false\n\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true\n    }\n  })\n\n  return hasSubList\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtStartOfNode, isNodeActive } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { hasListBefore } from './hasListBefore.js'\nimport { hasListItemBefore } from './hasListItemBefore.js'\nimport { listItemHasSubList } from './listItemHasSubList.js'\n\nexport const handleBackspace = (editor: Editor, name: string, parentListTypes: string[]) => {\n  // this is required to still handle the undo handling\n  if (editor.commands.undoInputRule()) {\n    return true\n  }\n\n  // if the selection is not collapsed\n  // we can rely on the default backspace behavior\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false\n  }\n\n  // if the current item is NOT inside a list item &\n  // the previous item is a list (orderedList or bulletList)\n  // move the cursor into the list and delete the current item\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection\n\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1)\n\n    const listDescendants: Array<{ node: Node; pos: number }> = []\n\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos })\n      }\n    })\n\n    const lastItem = listDescendants.at(-1)\n\n    if (!lastItem) {\n      return false\n    }\n\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1)\n\n    return editor\n      .chain()\n      .cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end())\n      .joinForward()\n      .run()\n  }\n\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the start of a node\n  // do nothing and proceed\n  if (!isAtStartOfNode(editor.state)) {\n    return false\n  }\n\n  const listItemPos = findListItemPos(name, editor.state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2)\n  const prevNode = $prev.node(listItemPos.depth)\n\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode)\n\n  // if the previous item is a list item and doesn't have a sublist, join the list items\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward()\n  }\n\n  // otherwise in the end, a backspace should\n  // always just lift the list item if\n  // joining / merging is not possible\n  return editor.chain().liftListItem(name).run()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsDeeper = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth > listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsHigher = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth < listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtEndOfNode, isNodeActive } from '@tiptap/core'\n\nimport { nextListIsDeeper } from './nextListIsDeeper.js'\nimport { nextListIsHigher } from './nextListIsHigher.js'\n\nexport const handleDelete = (editor: Editor, name: string) => {\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the end of a node\n  // do nothing and proceed\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false\n  }\n\n  // if the selection is not collapsed, or not within a single node\n  // do nothing and proceed\n  const { selection } = editor.state\n  const { $from, $to } = selection\n\n  if (!selection.empty && $from.sameParent($to)) {\n    return false\n  }\n\n  // check if the next node is a list with a deeper depth\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor\n      .chain()\n      .focus(editor.state.selection.from + 4)\n      .lift(name)\n      .joinBackward()\n      .run()\n  }\n\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run()\n  }\n\n  return editor.commands.joinItemForward()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemAfter = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2)\n\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false\n  }\n\n  if ($targetPos.nodeAfter?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { Extension } from '@tiptap/core'\n\nimport { handleBackspace, handleDelete } from './listHelpers/index.js'\n\nexport type ListKeymapOptions = {\n  /**\n   * An array of list types. This is used for item and wrapper list matching.\n   * @default []\n   * @example [{ itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] }]\n   */\n  listTypes: Array<{\n    itemName: string\n    wrapperNames: string[]\n  }>\n}\n\n/**\n * This extension registers custom keymaps to change the behaviour of the backspace and delete keys.\n * By default Prosemirror keyhandling will always lift or sink items so paragraphs are joined into\n * the adjacent or previous list item. This extension will prevent this behaviour and instead will\n * try to join paragraphs from two list items into a single list item.\n * @see https://www.tiptap.dev/api/extensions/list-keymap\n */\nexport const ListKeymap = Extension.create<ListKeymapOptions>({\n  name: 'listKeymap',\n\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: 'listItem',\n          wrapperNames: ['bulletList', 'orderedList'],\n        },\n        {\n          itemName: 'taskItem',\n          wrapperNames: ['taskList'],\n        },\n      ],\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Delete': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      Backspace: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Backspace': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n    }\n  },\n})\n","import type { JSONContent, MarkdownLexerConfiguration, MarkdownParseHelpers, MarkdownToken } from '@tiptap/core'\n\n/**\n * Matches an ordered list item line with optional leading whitespace.\n * Captures: (1) indentation spaces, (2) item number, (3) content after marker\n * Example matches: \"1. Item\", \"  2. Nested item\", \"    3. Deeply nested\"\n */\nconst ORDERED_LIST_ITEM_REGEX = /^(\\s*)(\\d+)\\.\\s+(.*)$/\n\n/**\n * Matches any line that starts with whitespace (indented content).\n * Used to identify continuation content that belongs to a list item.\n */\nconst INDENTED_LINE_REGEX = /^\\s/\n\n/**\n * Represents a parsed ordered list item with indentation information\n */\nexport interface OrderedListItem {\n  indent: number\n  number: number\n  content: string\n  raw: string\n}\n\n/**\n * Collects all ordered list items from lines, parsing them into a flat array\n * with indentation information. Stops collecting continuation content when\n * encountering nested list items, allowing them to be processed separately.\n *\n * @param lines - Array of source lines to parse\n * @returns Tuple of [listItems array, number of lines consumed]\n */\nexport function collectOrderedListItems(lines: string[]): [OrderedListItem[], number] {\n  const listItems: OrderedListItem[] = []\n  let currentLineIndex = 0\n  let consumed = 0\n\n  while (currentLineIndex < lines.length) {\n    const line = lines[currentLineIndex]\n    const match = line.match(ORDERED_LIST_ITEM_REGEX)\n\n    if (!match) {\n      break\n    }\n\n    const [, indent, number, content] = match\n    const indentLevel = indent.length\n    let itemContent = content\n    let nextLineIndex = currentLineIndex + 1\n    const itemLines = [line]\n\n    // Collect continuation lines for this item (but NOT nested list items)\n    while (nextLineIndex < lines.length) {\n      const nextLine = lines[nextLineIndex]\n      const nextMatch = nextLine.match(ORDERED_LIST_ITEM_REGEX)\n\n      // If it's another list item (nested or not), stop collecting\n      if (nextMatch) {\n        break\n      }\n\n      // Check for continuation content (non-list content)\n      if (nextLine.trim() === '') {\n        // Empty line\n        itemLines.push(nextLine)\n        itemContent += '\\n'\n        nextLineIndex += 1\n      } else if (nextLine.match(INDENTED_LINE_REGEX)) {\n        // Indented content - part of this item (but not a list item)\n        itemLines.push(nextLine)\n        itemContent += `\\n${nextLine.slice(indentLevel + 2)}` // Remove list marker indent\n        nextLineIndex += 1\n      } else {\n        // Non-indented line means end of list\n        break\n      }\n    }\n\n    listItems.push({\n      indent: indentLevel,\n      number: parseInt(number, 10),\n      content: itemContent.trim(),\n      raw: itemLines.join('\\n'),\n    })\n\n    consumed = nextLineIndex\n    currentLineIndex = nextLineIndex\n  }\n\n  return [listItems, consumed]\n}\n\n/**\n * Recursively builds a nested structure from a flat array of list items\n * based on their indentation levels. Creates proper markdown tokens with\n * nested lists where appropriate.\n *\n * @param items - Flat array of list items with indentation info\n * @param baseIndent - The indentation level to process at this recursion level\n * @param lexer - Markdown lexer for parsing inline and block content\n * @returns Array of list_item tokens with proper nesting\n */\nexport function buildNestedStructure(\n  items: OrderedListItem[],\n  baseIndent: number,\n  lexer: MarkdownLexerConfiguration,\n): unknown[] {\n  const result: unknown[] = []\n  let currentIndex = 0\n\n  while (currentIndex < items.length) {\n    const item = items[currentIndex]\n\n    if (item.indent === baseIndent) {\n      // This item belongs at the current level\n      const contentLines = item.content.split('\\n')\n      const mainText = contentLines[0]?.trim() || ''\n\n      const tokens = []\n\n      // Always wrap the main text in a paragraph token\n      if (mainText) {\n        tokens.push({\n          type: 'paragraph',\n          raw: mainText,\n          tokens: lexer.inlineTokens(mainText),\n        })\n      }\n\n      // Handle additional content after the main text\n      const additionalContent = contentLines.slice(1).join('\\n').trim()\n      if (additionalContent) {\n        // Parse as block tokens (handles mixed unordered lists, etc.)\n        const blockTokens = lexer.blockTokens(additionalContent)\n        tokens.push(...blockTokens)\n      }\n\n      // Look ahead to find nested items at deeper indent levels\n      let lookAheadIndex = currentIndex + 1\n      const nestedItems = []\n\n      while (lookAheadIndex < items.length && items[lookAheadIndex].indent > baseIndent) {\n        nestedItems.push(items[lookAheadIndex])\n        lookAheadIndex += 1\n      }\n\n      // If we have nested items, recursively build their structure\n      if (nestedItems.length > 0) {\n        // Find the next indent level (immediate children)\n        const nextIndent = Math.min(...nestedItems.map(nestedItem => nestedItem.indent))\n\n        // Build the nested list recursively with all nested items\n        // The recursive call will handle further nesting\n        const nestedListItems = buildNestedStructure(nestedItems, nextIndent, lexer)\n\n        // Create a nested list token\n        tokens.push({\n          type: 'list',\n          ordered: true,\n          start: nestedItems[0].number,\n          items: nestedListItems,\n          raw: nestedItems.map(nestedItem => nestedItem.raw).join('\\n'),\n        })\n      }\n\n      result.push({\n        type: 'list_item',\n        raw: item.raw,\n        tokens,\n      })\n\n      // Skip the nested items we just processed\n      currentIndex = lookAheadIndex\n    } else {\n      // This item has deeper indent than we're currently processing\n      // It should be handled by a recursive call\n      currentIndex += 1\n    }\n  }\n\n  return result\n}\n\n/**\n * Parses markdown list item tokens into Tiptap JSONContent structure,\n * ensuring text content is properly wrapped in paragraph nodes.\n *\n * @param items - Array of markdown tokens representing list items\n * @param helpers - Markdown parse helpers for recursive parsing\n * @returns Array of listItem JSONContent nodes\n */\nexport function parseListItems(items: MarkdownToken[], helpers: MarkdownParseHelpers): JSONContent[] {\n  return items.map(item => {\n    if (item.type !== 'list_item') {\n      return helpers.parseChildren([item])[0]\n    }\n\n    // Parse the tokens within the list item\n    const content: JSONContent[] = []\n\n    if (item.tokens && item.tokens.length > 0) {\n      item.tokens.forEach(itemToken => {\n        // If it's already a proper block node (paragraph, list, etc.), parse it directly\n        if (\n          itemToken.type === 'paragraph' ||\n          itemToken.type === 'list' ||\n          itemToken.type === 'blockquote' ||\n          itemToken.type === 'code'\n        ) {\n          content.push(...helpers.parseChildren([itemToken]))\n        } else if (itemToken.type === 'text' && itemToken.tokens) {\n          // If it's inline text tokens, wrap them in a paragraph\n          const inlineContent = helpers.parseChildren([itemToken])\n          content.push({\n            type: 'paragraph',\n            content: inlineContent,\n          })\n        } else {\n          // For any other content, try to parse it\n          const parsed = helpers.parseChildren([itemToken])\n          if (parsed.length > 0) {\n            content.push(...parsed)\n          }\n        }\n      })\n    }\n\n    return {\n      type: 'listItem',\n      content,\n    }\n  })\n}\n","import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nimport { buildNestedStructure, collectOrderedListItems, parseListItems } from './utils.js'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const orderedListInputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'list',\n\n  parseMarkdown: (token, helpers) => {\n    if (token.type !== 'list' || !token.ordered) {\n      return []\n    }\n\n    const startValue = token.start || 1\n    const content = token.items ? parseListItems(token.items, helpers) : []\n\n    if (startValue !== 1) {\n      return {\n        type: 'orderedList',\n        attrs: { start: startValue },\n        content,\n      }\n    }\n\n    return {\n      type: 'orderedList',\n      content,\n    }\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'orderedList',\n    level: 'block',\n    start: (src: string) => {\n      const match = src.match(/^(\\s*)(\\d+)\\.\\s+/)\n      const index = match?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize: (src: string, _tokens, lexer) => {\n      const lines = src.split('\\n')\n      const [listItems, consumed] = collectOrderedListItems(lines)\n\n      if (listItems.length === 0) {\n        return undefined\n      }\n\n      const items = buildNestedStructure(listItems, 0, lexer)\n\n      if (items.length === 0) {\n        return undefined\n      }\n\n      const startValue = listItems[0]?.number || 1\n\n      return {\n        type: 'list',\n        ordered: true,\n        start: startValue,\n        items,\n        raw: lines.slice(0, consumed).join('\\n'),\n      } as unknown as object\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport {\n  getRenderedAttributes,\n  mergeAttributes,\n  Node,\n  renderNestedMarkdownContent,\n  wrappingInputRule,\n} from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport interface TaskItemOptions {\n  /**\n   * A callback function that is called when the checkbox is clicked while the editor is in readonly mode.\n   * @param node The prosemirror node of the task item\n   * @param checked The new checked state\n   * @returns boolean\n   */\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n\n  /**\n   * Controls whether the task items can be nested or not.\n   * @default false\n   * @example true\n   */\n  nested: boolean\n\n  /**\n   * HTML attributes to add to the task item element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for taskList nodes\n   * @default 'taskList'\n   * @example 'myCustomTaskList'\n   */\n  taskListTypeName: string\n\n  /**\n   * Accessibility options for the task item.\n   * @default {}\n   * @example\n   * ```js\n   * {\n   *   checkboxLabel: (node) => `Task item: ${node.textContent || 'empty task item'}`\n   * }\n   */\n  a11y?: {\n    checkboxLabel?: (node: ProseMirrorNode, checked: boolean) => string\n  }\n}\n\n/**\n * Matches a task item to a - [ ] on input.\n */\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: 'taskList',\n      a11y: undefined,\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute('data-checked')\n\n          return dataChecked === '' || dataChecked === 'true'\n        },\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  parseMarkdown: (token, h) => {\n    // Parse the task item's text content into paragraph content\n    const content = []\n\n    // First, add the main paragraph content\n    if (token.tokens && token.tokens.length > 0) {\n      // If we have tokens, create a paragraph with the inline content\n      content.push(h.createNode('paragraph', {}, h.parseInline(token.tokens)))\n    } else if (token.text) {\n      // If we have raw text, create a paragraph with text node\n      content.push(h.createNode('paragraph', {}, [h.createNode('text', { text: token.text })]))\n    } else {\n      // Fallback: empty paragraph\n      content.push(h.createNode('paragraph', {}, []))\n    }\n\n    // Then, add any nested content (like nested task lists)\n    if (token.nestedTokens && token.nestedTokens.length > 0) {\n      const nestedContent = h.parseChildren(token.nestedTokens)\n      content.push(...nestedContent)\n    }\n\n    return h.createNode('taskItem', { checked: token.checked || false }, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    const checkedChar = node.attrs?.checked ? 'x' : ' '\n    const prefix = `- [${checkedChar}] `\n\n    return renderNestedMarkdownContent(node, h, prefix)\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts: {\n      [key: string]: KeyboardShortcutCommand\n    } = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      const updateA11Y = (currentNode: ProseMirrorNode) => {\n        checkbox.ariaLabel =\n          this.options.a11y?.checkboxLabel?.(currentNode, checkbox.checked) ||\n          `Task item checkbox for ${currentNode.textContent || 'empty task item'}`\n      }\n\n      updateA11Y(node)\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('mousedown', event => event.preventDefault())\n      checkbox.addEventListener('change', event => {\n        // if the editor isnt editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n\n              if (typeof position !== 'number') {\n                return false\n              }\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      checkbox.checked = node.attrs.checked\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      // Track the keys of previously rendered HTML attributes for proper removal\n      let prevRenderedAttributeKeys = new Set(Object.keys(HTMLAttributes))\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          checkbox.checked = updatedNode.attrs.checked\n          updateA11Y(updatedNode)\n\n          // Sync all HTML attributes from the updated node\n          const extensionAttributes = editor.extensionManager.attributes\n          const newHTMLAttributes = getRenderedAttributes(updatedNode, extensionAttributes)\n          const newKeys = new Set(Object.keys(newHTMLAttributes))\n\n          // Remove attributes that were previously rendered but are no longer present\n          // If the attribute exists in static options, restore it instead of removing\n          const staticAttrs = this.options.HTMLAttributes\n\n          prevRenderedAttributeKeys.forEach(key => {\n            if (!newKeys.has(key)) {\n              if (key in staticAttrs) {\n                listItem.setAttribute(key, staticAttrs[key])\n              } else {\n                listItem.removeAttribute(key)\n              }\n            }\n          })\n\n          // Update or add new attributes\n          Object.entries(newHTMLAttributes).forEach(([key, value]) => {\n            if (value === null || value === undefined) {\n              // If the attribute exists in static options, restore it instead of removing\n              if (key in staticAttrs) {\n                listItem.setAttribute(key, staticAttrs[key])\n              } else {\n                listItem.removeAttribute(key)\n              }\n            } else {\n              listItem.setAttribute(key, value)\n            }\n          })\n\n          // Update the tracked keys for next update\n          prevRenderedAttributeKeys = newKeys\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n","import { mergeAttributes, Node, parseIndentedBlocks } from '@tiptap/core'\n\nexport interface TaskListOptions {\n  /**\n   * The node type name for a task item.\n   * @default 'taskItem'\n   * @example 'myCustomTaskItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for a task list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    taskList: {\n      /**\n       * Toggle a task list\n       * @example editor.commands.toggleTaskList()\n       */\n      toggleTaskList: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */\nexport const TaskList = Node.create<TaskListOptions>({\n  name: 'taskList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'taskItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': this.name }), 0]\n  },\n\n  parseMarkdown: (token, h) => {\n    return h.createNode('taskList', {}, h.parseChildren(token.items || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node.content) {\n      return ''\n    }\n\n    return h.renderChildren(node.content, '\\n')\n  },\n\n  markdownTokenizer: {\n    name: 'taskList',\n    level: 'block',\n    start(src) {\n      // Look for the start of a task list item\n      const index = src.match(/^\\s*[-+*]\\s+\\[([ xX])\\]\\s+/)?.index\n      return index !== undefined ? index : -1\n    },\n    tokenize(src, tokens, lexer) {\n      // Helper function to recursively parse task lists\n      const parseTaskListContent = (content: string): any[] | undefined => {\n        const nestedResult = parseIndentedBlocks(\n          content,\n          {\n            itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n            extractItemData: match => ({\n              indentLevel: match[1].length,\n              mainContent: match[4],\n              checked: match[3].toLowerCase() === 'x',\n            }),\n            createToken: (data, nestedTokens) => ({\n              type: 'taskItem',\n              raw: '',\n              mainContent: data.mainContent,\n              indentLevel: data.indentLevel,\n              checked: data.checked,\n              text: data.mainContent,\n              tokens: lexer.inlineTokens(data.mainContent),\n              nestedTokens,\n            }),\n            // Allow recursive nesting\n            customNestedParser: parseTaskListContent,\n          },\n          lexer,\n        )\n\n        if (nestedResult) {\n          // Return as task list token\n          return [\n            {\n              type: 'taskList',\n              raw: nestedResult.raw,\n              items: nestedResult.items,\n            },\n          ]\n        }\n\n        // Fall back to regular markdown parsing if not a task list\n        return lexer.blockTokens(content)\n      }\n\n      const result = parseIndentedBlocks(\n        src,\n        {\n          itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n          extractItemData: match => ({\n            indentLevel: match[1].length,\n            mainContent: match[4],\n            checked: match[3].toLowerCase() === 'x',\n          }),\n          createToken: (data, nestedTokens) => ({\n            type: 'taskItem',\n            raw: '',\n            mainContent: data.mainContent,\n            indentLevel: data.indentLevel,\n            checked: data.checked,\n            text: data.mainContent,\n            tokens: lexer.inlineTokens(data.mainContent),\n            nestedTokens,\n          }),\n          // Use the recursive parser for nested content\n          customNestedParser: parseTaskListContent,\n        },\n        lexer,\n      )\n\n      if (!result) {\n        return undefined\n      }\n\n      return {\n        type: 'taskList',\n        raw: result.raw,\n        items: result.items,\n      }\n    },\n  },\n\n  markdownOptions: {\n    indentsContent: true,\n  },\n\n  addCommands() {\n    return {\n      toggleTaskList:\n        () =>\n        ({ commands }) => {\n          return commands.toggleList(this.name, this.options.itemTypeName)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),\n    }\n  },\n})\n","import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface ParagraphOptions {\n  /**\n   * The HTML attributes for a paragraph node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    paragraph: {\n      /**\n       * Toggle a paragraph\n       * @example editor.commands.toggleParagraph()\n       */\n      setParagraph: () => ReturnType\n    }\n  }\n}\n\n/**\n * Markdown marker for empty paragraphs to preserve blank lines.\n * Using &nbsp; (non-breaking space HTML entity) ensures the paragraph\n * is not collapsed by markdown parsers while remaining human-readable.\n */\nconst EMPTY_PARAGRAPH_MARKDOWN = '&nbsp;'\n\n/**\n * Unicode character for non-breaking space (U+00A0).\n * Some markdown parsers may convert &nbsp; entities to this literal character.\n */\nconst NBSP_CHAR = '\\u00A0'\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */\nexport const Paragraph = Node.create<ParagraphOptions>({\n  name: 'paragraph',\n\n  priority: 1000,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  content: 'inline*',\n\n  parseHTML() {\n    return [{ tag: 'p' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown: (token, helpers) => {\n    const tokens = token.tokens || []\n\n    // Special case: if paragraph contains only a single image token,\n    // unwrap it to avoid nesting block elements incorrectly\n    if (tokens.length === 1 && tokens[0].type === 'image') {\n      // Parse the image token directly as a block element\n      return helpers.parseChildren([tokens[0]])\n    }\n\n    // Parse the inline tokens\n    const content = helpers.parseInline(tokens)\n\n    // Special case: if paragraph contains only &nbsp; (non-breaking space),\n    // treat it as an empty paragraph to preserve blank lines\n    if (\n      content.length === 1 &&\n      content[0].type === 'text' &&\n      (content[0].text === EMPTY_PARAGRAPH_MARKDOWN || content[0].text === NBSP_CHAR)\n    ) {\n      return helpers.createNode('paragraph', undefined, [])\n    }\n\n    // Convert 'paragraph' token to paragraph node\n    return helpers.createNode('paragraph', undefined, content)\n  },\n\n  renderMarkdown: (node, h) => {\n    if (!node) {\n      return ''\n    }\n\n    // Normalize content: treat undefined/null as empty array\n    const content = Array.isArray(node.content) ? node.content : []\n\n    // If the paragraph is empty, render a non-breaking space to preserve blank lines\n    if (content.length === 0) {\n      return EMPTY_PARAGRAPH_MARKDOWN\n    }\n\n    return h.renderChildren(content)\n  },\n\n  addCommands() {\n    return {\n      setParagraph:\n        () =>\n        ({ commands }) => {\n          return commands.setNode(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n    }\n  },\n})\n","import { Extension } from '@tiptap/core'\n\nimport type { BulletListOptions } from '../bullet-list/index.js'\nimport { BulletList } from '../bullet-list/index.js'\nimport type { ListItemOptions } from '../item/index.js'\nimport { ListItem } from '../item/index.js'\nimport type { ListKeymapOptions } from '../keymap/index.js'\nimport { ListKeymap } from '../keymap/index.js'\nimport type { OrderedListOptions } from '../ordered-list/index.js'\nimport { OrderedList } from '../ordered-list/index.js'\nimport type { TaskItemOptions } from '../task-item/index.js'\nimport { TaskItem } from '../task-item/index.js'\nimport type { TaskListOptions } from '../task-list/index.js'\nimport { TaskList } from '../task-list/index.js'\n\nexport interface ListKitOptions {\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example table: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n  /**\n   * If set to false, the listItem extension will not be registered\n   */\n  listItem: Partial<ListItemOptions> | false\n  /**\n   * If set to false, the listKeymap extension will not be registered\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n  /**\n   * If set to false, the orderedList extension will not be registered\n   */\n  orderedList: Partial<OrderedListOptions> | false\n  /**\n   * If set to false, the taskItem extension will not be registered\n   */\n  taskItem: Partial<TaskItemOptions> | false\n  /**\n   * If set to false, the taskList extension will not be registered\n   */\n  taskList: Partial<TaskListOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * Its a good starting point for building your own table in Tiptap.\n */\nexport const ListKit = Extension.create<ListKitOptions>({\n  name: 'listKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem))\n    }\n\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList))\n    }\n\n    return extensions\n  },\n})\n","import { Mark, markInputRule, markPasteRule, mergeAttributes } from '@tiptap/core'\n\nexport interface StrikeOptions {\n  /**\n   * HTML attributes to add to the strike element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    strike: {\n      /**\n       * Set a strike mark\n       * @example editor.commands.setStrike()\n       */\n      setStrike: () => ReturnType\n      /**\n       * Toggle a strike mark\n       * @example editor.commands.toggleStrike()\n       */\n      toggleStrike: () => ReturnType\n      /**\n       * Unset a strike mark\n       * @example editor.commands.unsetStrike()\n       */\n      unsetStrike: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */\nexport const inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/\n\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */\nexport const pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g\n\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */\nexport const Strike = Mark.create<StrikeOptions>({\n  name: 'strike',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 's',\n      },\n      {\n        tag: 'del',\n      },\n      {\n        tag: 'strike',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('line-through') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  markdownTokenName: 'del',\n\n  parseMarkdown: (token, helpers) => {\n    // Convert 'del' token to strike mark\n    return helpers.applyMark('strike', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown: (node, h) => {\n    return `~~${h.renderChildren(node)}~~`\n  },\n\n  addCommands() {\n    return {\n      setStrike:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleStrike:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetStrike:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-s': () => this.editor.commands.toggleStrike(),\n    }\n  },\n\n  addInputRules() {\n    return [\n      markInputRule({\n        find: inputRegex,\n        type: this.type,\n      }),\n    ]\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: pasteRegex,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { Node } from '@tiptap/core'\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */\nexport const Text = Node.create({\n  name: 'text',\n  group: 'inline',\n\n  parseMarkdown: token => {\n    // Convert 'text' token to text node - text nodes are special as they store text directly\n    return {\n      type: 'text',\n      text: token.text || '',\n    }\n  },\n\n  renderMarkdown: node => node.text || '',\n})\n","import { TextAlign } from './text-align.js'\n\nexport * from './text-align.js'\n\nexport default TextAlign\n","import { Extension } from '@tiptap/core'\n\nexport interface TextAlignOptions {\n  /**\n   * The types where the text align attribute can be applied.\n   * @default []\n   * @example ['heading', 'paragraph']\n   */\n  types: string[]\n\n  /**\n   * The alignments which are allowed.\n   * @default ['left', 'center', 'right', 'justify']\n   * @example ['left', 'right']\n   */\n  alignments: string[]\n\n  /**\n   * The default alignment.\n   * @default null\n   * @example 'center'\n   */\n  defaultAlignment: string | null\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    textAlign: {\n      /**\n       * Set the text align attribute\n       * @param alignment The alignment\n       * @example editor.commands.setTextAlign('left')\n       */\n      setTextAlign: (alignment: string) => ReturnType\n      /**\n       * Unset the text align attribute\n       * @example editor.commands.unsetTextAlign()\n       */\n      unsetTextAlign: () => ReturnType\n      /**\n       * Toggle the text align attribute\n       * @param alignment The alignment\n       * @example editor.commands.toggleTextAlign('right')\n       */\n      toggleTextAlign: (alignment: string) => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to align text.\n * @see https://www.tiptap.dev/api/extensions/text-align\n */\nexport const TextAlign = Extension.create<TextAlignOptions>({\n  name: 'textAlign',\n\n  addOptions() {\n    return {\n      types: [],\n      alignments: ['left', 'center', 'right', 'justify'],\n      defaultAlignment: null,\n    }\n  },\n\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          textAlign: {\n            default: this.options.defaultAlignment,\n            parseHTML: element => {\n              const alignment = element.style.textAlign\n\n              return this.options.alignments.includes(alignment) ? alignment : this.options.defaultAlignment\n            },\n            renderHTML: attributes => {\n              if (!attributes.textAlign) {\n                return {}\n              }\n\n              return { style: `text-align: ${attributes.textAlign}` }\n            },\n          },\n        },\n      },\n    ]\n  },\n\n  addCommands() {\n    return {\n      setTextAlign:\n        (alignment: string) =>\n        ({ commands }) => {\n          if (!this.options.alignments.includes(alignment)) {\n            return false\n          }\n\n          return this.options.types\n            .map(type => commands.updateAttributes(type, { textAlign: alignment }))\n            .some(response => response)\n        },\n\n      unsetTextAlign:\n        () =>\n        ({ commands }) => {\n          return this.options.types.map(type => commands.resetAttributes(type, 'textAlign')).some(response => response)\n        },\n\n      toggleTextAlign:\n        alignment =>\n        ({ editor, commands }) => {\n          if (!this.options.alignments.includes(alignment)) {\n            return false\n          }\n\n          if (editor.isActive({ textAlign: alignment })) {\n            return commands.unsetTextAlign()\n          }\n          return commands.setTextAlign(alignment)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-l': () => this.editor.commands.setTextAlign('left'),\n      'Mod-Shift-e': () => this.editor.commands.setTextAlign('center'),\n      'Mod-Shift-r': () => this.editor.commands.setTextAlign('right'),\n      'Mod-Shift-j': () => this.editor.commands.setTextAlign('justify'),\n    }\n  },\n})\n","import { Mark, mergeAttributes } from '@tiptap/core'\n\nexport interface UnderlineOptions {\n  /**\n   * HTML attributes to add to the underline element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    underline: {\n      /**\n       * Set an underline mark\n       * @example editor.commands.setUnderline()\n       */\n      setUnderline: () => ReturnType\n      /**\n       * Toggle an underline mark\n       * @example editor.commands.toggleUnderline()\n       */\n      toggleUnderline: () => ReturnType\n      /**\n       * Unset an underline mark\n       * @example editor.commands.unsetUnderline()\n       */\n      unsetUnderline: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create underline text.\n * @see https://www.tiptap.dev/api/marks/underline\n */\nexport const Underline = Mark.create<UnderlineOptions>({\n  name: 'underline',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'u',\n      },\n      {\n        style: 'text-decoration',\n        consuming: false,\n        getAttrs: style => ((style as string).includes('underline') ? {} : false),\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['u', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  parseMarkdown(token, helpers) {\n    return helpers.applyMark(this.name || 'underline', helpers.parseInline(token.tokens || []))\n  },\n\n  renderMarkdown(node, helpers) {\n    return `++${helpers.renderChildren(node)}++`\n  },\n\n  markdownTokenizer: {\n    name: 'underline',\n    level: 'inline',\n    start(src) {\n      return src.indexOf('++')\n    },\n    tokenize(src, _tokens, lexer) {\n      const rule = /^(\\+\\+)([\\s\\S]+?)(\\+\\+)/\n      const match = rule.exec(src)\n\n      if (!match) {\n        return undefined\n      }\n\n      const innerContent = match[2].trim()\n\n      return {\n        type: 'underline',\n        raw: match[0],\n        text: innerContent,\n        tokens: lexer.inlineTokens(innerContent),\n      }\n    },\n  },\n\n  addCommands() {\n    return {\n      setUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.setMark(this.name)\n        },\n      toggleUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.toggleMark(this.name)\n        },\n      unsetUnderline:\n        () =>\n        ({ commands }) => {\n          return commands.unsetMark(this.name)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-u': () => this.editor.commands.toggleUnderline(),\n      'Mod-U': () => this.editor.commands.toggleUnderline(),\n    }\n  },\n})\n","import {\n  __spreadValues,\n  init_react_import\n} from \"./chunk-M6W7YEVX.mjs\";\n\n// components/RichTextEditor/extension.ts\ninit_react_import();\nimport { Extension } from \"@tiptap/core\";\nimport { Blockquote } from \"@tiptap/extension-blockquote\";\nimport { Bold } from \"@tiptap/extension-bold\";\nimport { Code } from \"@tiptap/extension-code\";\nimport { CodeBlock } from \"@tiptap/extension-code-block\";\nimport { Document } from \"@tiptap/extension-document\";\nimport { HardBreak } from \"@tiptap/extension-hard-break\";\nimport { Heading } from \"@tiptap/extension-heading\";\nimport { HorizontalRule } from \"@tiptap/extension-horizontal-rule\";\nimport { Italic } from \"@tiptap/extension-italic\";\nimport { Link } from \"@tiptap/extension-link\";\nimport {\n  BulletList,\n  ListItem,\n  ListKeymap,\n  OrderedList\n} from \"@tiptap/extension-list\";\nimport { Paragraph } from \"@tiptap/extension-paragraph\";\nimport { Strike } from \"@tiptap/extension-strike\";\nimport { Text } from \"@tiptap/extension-text\";\nimport TextAlign from \"@tiptap/extension-text-align\";\nimport { Underline } from \"@tiptap/extension-underline\";\nvar defaultPuckRichTextOptions = {\n  textAlign: {\n    types: [\"heading\", \"paragraph\"]\n  }\n};\nvar PuckRichText = Extension.create({\n  name: \"puckRichText\",\n  addExtensions() {\n    const extensions = [];\n    const options = __spreadValues(__spreadValues({}, this.options), defaultPuckRichTextOptions);\n    if (options.bold !== false) {\n      extensions.push(Bold.configure(options.bold));\n    }\n    if (options.blockquote !== false) {\n      extensions.push(Blockquote.configure(options.blockquote));\n    }\n    if (options.code !== false) {\n      extensions.push(Code.configure(options.code));\n    }\n    if (options.codeBlock !== false) {\n      extensions.push(CodeBlock.configure(options.codeBlock));\n    }\n    if (options.document !== false) {\n      extensions.push(Document.configure(options.document));\n    }\n    if (options.hardBreak !== false) {\n      extensions.push(HardBreak.configure(options.hardBreak));\n    }\n    if (options.heading !== false) {\n      extensions.push(Heading.configure(options.heading));\n    }\n    if (options.horizontalRule !== false) {\n      extensions.push(HorizontalRule.configure(options.horizontalRule));\n    }\n    if (options.italic !== false) {\n      extensions.push(Italic.configure(options.italic));\n    }\n    if (options.listItem !== false) {\n      extensions.push(ListItem.configure(options.listItem));\n      if (options.bulletList !== false) {\n        extensions.push(BulletList.configure(options.bulletList));\n      }\n      if (options.orderedList !== false) {\n        extensions.push(OrderedList.configure(options.orderedList));\n      }\n    }\n    if (options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(options == null ? void 0 : options.listKeymap));\n    }\n    if (options.link !== false) {\n      extensions.push(Link.configure(options == null ? void 0 : options.link));\n    }\n    if (options.paragraph !== false) {\n      extensions.push(Paragraph.configure(options.paragraph));\n    }\n    if (options.strike !== false) {\n      extensions.push(Strike.configure(options.strike));\n    }\n    if (options.text !== false) {\n      extensions.push(Text.configure(options.text));\n    }\n    if (options.textAlign !== false) {\n      extensions.push(TextAlign.configure(options.textAlign));\n    }\n    if (options.underline !== false) {\n      extensions.push(Underline.configure(options == null ? void 0 : options.underline));\n    }\n    return extensions;\n  }\n});\n\nexport {\n  PuckRichText\n};\n"],"names":["h","tag","attributes","Function","_ref","children","rest","_objectWithoutProperties","_excluded","Error","inputRegex","Blockquote","Node","create","name","addOptions","HTMLAttributes","content","group","defining","parseHTML","renderHTML","jsx","_objectSpread","mergeAttributes","this","options","parseMarkdown","token","helpers","createNode","parseChildren","tokens","renderMarkdown","node","result","forEach","child","linesWithPrefix","renderChildren","split","map","line","trim","concat","push","join","addCommands","setBlockquote","_ref2","commands","wrapIn","toggleBlockquote","_ref3","toggleWrap","unsetBlockquote","_ref4","lift","addKeyboardShortcuts","Mod-Shift-b","editor","addInputRules","wrappingInputRule","find","type","starInputRegex","starPasteRegex","underscoreInputRegex","underscorePasteRegex","Bold","Mark","getAttrs","style","fontWeight","clearMark","mark","value","test","markdownTokenName","applyMark","parseInline","setBold","setMark","toggleBold","toggleMark","unsetBold","unsetMark","Mod-b","Mod-B","markInputRule","addPasteRules","markPasteRule","pasteRegex","Code","excludes","code","exitable","text","setCode","toggleCode","unsetCode","Mod-e","backtickInputRegex","tildeInputRegex","CodeBlock","languageClassPrefix","exitOnTripleEnter","exitOnArrowDown","defaultLanguage","enableTabIndentation","tabSize","marks","addAttributes","language","default","element","_a","firstElementChild","classList","filter","className","startsWith","replace","rendered","preserveWhitespace","class","attrs","raw","codeBlockStyle","lang","createTextNode","output","setCodeBlock","setNode","toggleCodeBlock","toggleNode","Mod-Alt-c","Backspace","empty","$anchor","state","selection","isAtStart","pos","parent","textContent","length","clearNodes","Tab","$from","indent","repeat","insertContent","command","_ref5","tr","from","to","indentedText","doc","textBetween","replaceWith","schema","_ref6","_ref7","_a2","codeBlockStart","start","codeBlockEnd","end","lines","currentLineIndex","charCount","relativeCursorPos","i","leadingSpaces","match","spacesToRemove","Math","min","lineStartPos","delete","setSelection","TextSelection","_ref8","reverseIndentText","slice","Enter","_ref9","isAtEnd","parentOffset","nodeSize","endsWithDoubleNewline","endsWith","chain","_ref0","exitCode","run","ArrowDown","_ref1","after","nodeAt","_ref10","Selection","near","resolve","textblockTypeInputRule","getAttributes","addProseMirrorPlugins","Plugin","key","PluginKey","props","handlePaste","view","event","clipboardData","isActive","getData","vscode","vscodeData","JSON","parse","mode","textNode","replaceSelectionWith","max","setMeta","dispatch","Document","topNode","HardBreak","keepMarks","inline","selectable","linebreakReplacement","renderText","setHardBreak","first","storedMarks","spec","isolating","splittableMarks","extensionManager","$to","filteredMarks","includes","ensureMarks","Mod-Enter","Shift-Enter","Heading","levels","level","depth","parseInt","headingChars","setHeading","toggleHeading","reduce","items","RegExp","HorizontalRule","nextNodeType","setHorizontalRule","canInsertNode","nodes","$originTo","currentChain","isNodeSelection","insertContentAt","chainState","posAfter","nodeAfter","isTextblock","isBlock","NodeSelection","nodeType","contentMatch","defaultType","insert","scrollIntoView","nodeInputRule","Italic","fontStyle","setItalic","toggleItalic","unsetItalic","Mod-i","Mod-I","numeric","ascii","alpha","asciinumeric","alphanumeric","domain","emoji","scheme","slashscheme","whitespace","registerGroup","groups","addToGroups","t","flags","k","indexOf","State","arguments","undefined","j","jr","jd","prototype","accepts","go","input","nextState","regex","has","ta","inputs","next","tt","regexp","ts","len","templateState","Object","assign","apply","allFlags","c","flagsForToken","WORD","UWORD","ASCIINUMERICAL","ALPHANUMERICAL","LOCALHOST","TLD","UTLD","SCHEME","SLASH_SCHEME","NUM","WS","NL","OPENBRACE","CLOSEBRACE","OPENBRACKET","CLOSEBRACKET","OPENPAREN","CLOSEPAREN","OPENANGLEBRACKET","CLOSEANGLEBRACKET","FULLWIDTHLEFTPAREN","FULLWIDTHRIGHTPAREN","LEFTCORNERBRACKET","RIGHTCORNERBRACKET","LEFTWHITECORNERBRACKET","RIGHTWHITECORNERBRACKET","FULLWIDTHLESSTHAN","FULLWIDTHGREATERTHAN","AMPERSAND","APOSTROPHE","ASTERISK","AT","BACKSLASH","BACKTICK","CARET","COLON","COMMA","DOLLAR","DOT","EQUALS","EXCLAMATION","HYPHEN","PERCENT","PIPE","PLUS","POUND","QUERY","QUOTE","FULLWIDTHMIDDLEDOT","SEMI","SLASH","TILDE","UNDERSCORE","EMOJI$1","SYM","tk","freeze","__proto__","EMOJI","ASCII_LETTER","LETTER","DIGIT","SPACE","tlds","utlds","run$1","str","iterable","index","second","charCodeAt","char","stringToArray","toLowerCase","cursor","charCursor","tokenLength","latestAccepting","sinceAccepts","charsSinceAccepts","v","s","e","fastts","defaultt","decodeTlds","encoded","words","stack","popDigitCount","popCount","substring","pop","defaults","defaultProtocol","events","format","noop","formatHref","nl2br","tagName","target","rel","validate","truncate","Infinity","ignoreTags","render","Options","opts","defaultRender","o","ignoredTags","uppercaseIgnoredTags","toUpperCase","val","ir","check","get","toString","operator","isCallable","option","getObj","obj","MultiToken","createTokenClass","Token","constructor","super","p","isLink","toHref","toFormattedString","formatted","toFormattedHref","startIndex","endIndex","toObject","protocol","href","toFormattedObject","formattedHref","eventListeners","Email","Text","Nl","Url","hasProtocol","makeState","arg","initMultiToken","Multi","startIdx","endIdx","warn","console","warnAdvice","INIT","scanner","parser","tokenQueue","pluginQueue","customSchemes","initialized","registerCustomProtocol","optionalSlashSlash","init","Start","Num","Asciinumeric","Alphanumeric","Word","UWord","Cr","Ws","Emoji","EmojiJoiner","wordjr","uwordjr","tld","utld","sort","a","b","sch","init$2","qsAccepting","qsNonAccepting","localpartAccepting","Localpart","Domain","Scheme","SlashScheme","LocalpartAt","LocalpartDot","EmailDomain","EmailDomainDot","Email$1","EmailDomainHyphen","EmailColon","DomainHyphen","DomainDot","DomainDotTld","DomainDotTldColon","DomainDotTldColonPort","Url$1","UrlNonaccept","SchemeColon","SlashSchemeColon","SlashSchemeColonSlash","UriPrefix","bracketPairs","OPEN","CLOSE","UrlOpen","UrlOpenQ","UrlOpenSyms","init$1","tokenize","multis","textTokens","secondState","multiLength","subtokens","filtered","scan","UNICODE_WHITESPACE_PATTERN","UNICODE_WHITESPACE_REGEX","UNICODE_WHITESPACE_REGEX_END","UNICODE_WHITESPACE_REGEX_GLOBAL","isAllowedUri","uri","protocols","allowedProtocols","nextProtocol","Link","priority","keepOnSplit","onCreate","shouldAutoLink","optionalSlashes","onDestroy","inclusive","autolink","openOnClick","enableClickSelection","linkOnPaste","url","ctx","hasMaybeProtocol","hostname","getAttribute","title","dom","defaultValidate","_b","_c","_d","setLink","toggleLink","extendEmptyMarkRange","unsetLink","foundLinks","links","find2","item","link","data","plugins","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","eq","preventAutolink","getMeta","transform","combineTransactionSteps","getChangedRanges","newRange","nodesInChangedRanges","findChildrenInRange","textBlock","textBeforeWhitespace","endText","wordsBeforeWhitespace","Boolean","lastWordBeforeSpace","lastWordAndBlockOffset","lastIndexOf","linksBeforeSpace","rangeHasMark","getMarksBetween","addMark","steps","Plugin2","PluginKey2","handleClick","button","editable","HTMLAnchorElement","root","closest","contains","handled","extendMarkRange","window","open","clickHandler","Plugin3","PluginKey3","_event","pasteHandler","TextStyleName","bulletListInputRegex","BulletList","itemTypeName","keepAttributes","ordered","markdownOptions","indentsContent","toggleBulletList","toggleList","updateAttributes","Mod-Shift-8","inputRule","ListItem","Node2","bulletListTypeName","orderedListTypeName","mergeAttributes2","firstToken","remainingTokens","additionalContent","renderNestedMarkdownContent","context","parentType","meta","parentAttrs","splitListItem","sinkListItem","Shift-Tab","liftListItem","__export","findListItemPos","getNextListDepth","handleBackspace","handleDelete","hasListBefore","hasListItemAfter","hasListItemBefore","listItemHasSubList","nextListIsDeeper","nextListIsHigher","typeOrName","getNodeType","currentNode","currentDepth","currentPos","targetDepth","$pos","listItemPos","getNodeAtPosition","editorState","parentListTypes","previousNodePos","previousNode","$targetPos","nodeBefore","getNodeType2","hasSubList","descendants","undoInputRule","isNodeActive","$listPos","before","listDescendants","lastItem","at","$lastItemPos","cut","joinForward","isAtStartOfNode","prevNode","previousListItemHasSubList","joinItemBackward","listDepth","isNodeActive2","isAtEndOfNode","sameParent","focus","joinBackward","joinItemForward","childCount","ListKeymap","Extension","listTypes","itemName","wrapperNames","Delete","ORDERED_LIST_ITEM_REGEX","INDENTED_LINE_REGEX","buildNestedStructure","baseIndent","lexer","currentIndex","contentLines","mainText","inlineTokens","blockTokens","lookAheadIndex","nestedItems","nextIndent","nestedItem","nestedListItems","number","TextStyleName2","orderedListInputRegex","OrderedList","Node3","hasAttribute","attributesWithoutStart","mergeAttributes3","startValue","itemToken","inlineContent","parsed","parseListItems","markdownTokenizer","src","_tokens","listItems","consumed","indentLevel","itemContent","nextLineIndex","itemLines","nextLine","collectOrderedListItems","toggleOrderedList","_ref11","Mod-Shift-7","wrappingInputRule2","joinPredicate","TaskItem","Node4","nested","taskListTypeName","a11y","checked","dataChecked","_ref12","mergeAttributes4","nestedTokens","nestedContent","checkedChar","prefix","renderNestedMarkdownContent2","shortcuts","addNodeView","_ref13","getPos","listItem","document","createElement","checkboxWrapper","checkboxStyler","checkbox","updateA11Y","ariaLabel","checkboxLabel","call","contentEditable","addEventListener","preventDefault","isEditable","onReadOnlyChecked","_ref14","position","setNodeMarkup","entries","_ref15","setAttribute","dataset","append","_ref16","prevRenderedAttributeKeys","Set","keys","contentDOM","update","updatedNode","extensionAttributes","newHTMLAttributes","getRenderedAttributes","newKeys","staticAttrs","removeAttribute","_ref17","wrappingInputRule3","TaskList","Node5","_ref18","mergeAttributes5","parseTaskListContent","nestedResult","parseIndentedBlocks","itemPattern","extractItemData","mainContent","createToken","customNestedParser","toggleTaskList","_ref19","Mod-Shift-9","EMPTY_PARAGRAPH_MARKDOWN","Extension2","addExtensions","extensions","bulletList","configure","listKeymap","orderedList","taskItem","taskList","Paragraph","Array","isArray","setParagraph","Mod-Alt-0","Strike","consuming","setStrike","toggleStrike","unsetStrike","Mod-Shift-s","index_default","types","alignments","defaultAlignment","addGlobalAttributes","textAlign","alignment","setTextAlign","response","unsetTextAlign","resetAttributes","toggleTextAlign","Mod-Shift-l","Mod-Shift-e","Mod-Shift-r","Mod-Shift-j","Underline","exec","innerContent","setUnderline","toggleUnderline","unsetUnderline","Mod-u","Mod-U","init_react_import","defaultPuckRichTextOptions","PuckRichText","__spreadValues","bold","blockquote","codeBlock","hardBreak","heading","horizontalRule","italic","paragraph","strike","TextAlign","underline"],"sourceRoot":""}