{"version":3,"file":"static/js/580.65579111.chunk.js","mappings":";+FAWA,IAAIA,EAAQC,EAAQ,IAIpB,IAAIC,EAAW,oBAAsBC,OAAOC,GAAKD,OAAOC,GAHxD,SAAYC,EAAGC,GACb,OAAQD,IAAMC,IAAM,IAAMD,GAAK,EAAIA,IAAM,EAAIC,IAAQD,IAAMA,GAAKC,IAAMA,CACxE,EAEEC,EAAWP,EAAMO,SACjBC,EAAYR,EAAMQ,UAClBC,EAAkBT,EAAMS,gBACxBC,EAAgBV,EAAMU,cA0BxB,SAASC,EAAuBC,GAC9B,IAAIC,EAAoBD,EAAKE,YAC7BF,EAAOA,EAAKG,MACZ,IACE,IAAIC,EAAYH,IAChB,OAAQX,EAASU,EAAMI,EACzB,CAAE,MAAOC,GACP,OAAO,CACT,CACF,CAIA,IAAIC,EACF,qBAAuBC,QACvB,qBAAuBA,OAAOC,UAC9B,qBAAuBD,OAAOC,SAASC,cANzC,SAAgCC,EAAWR,GACzC,OAAOA,GACT,EArCA,SAAgCQ,EAAWR,GACzC,IAAIC,EAAQD,IACVS,EAAYhB,EAAS,CAAEK,KAAM,CAAEG,MAAOA,EAAOD,YAAaA,KAC1DF,EAAOW,EAAU,GAAGX,KACpBY,EAAcD,EAAU,GAmB1B,OAlBAd,EACE,WACEG,EAAKG,MAAQA,EACbH,EAAKE,YAAcA,EACnBH,EAAuBC,IAASY,EAAY,CAAEZ,KAAMA,GACtD,EACA,CAACU,EAAWP,EAAOD,IAErBN,EACE,WAEE,OADAG,EAAuBC,IAASY,EAAY,CAAEZ,KAAMA,IAC7CU,EAAU,WACfX,EAAuBC,IAASY,EAAY,CAAEZ,KAAMA,GACtD,EACF,EACA,CAACU,IAEHZ,EAAcK,GACPA,CACT,EAoBAU,EAAQC,0BACD,IAAM1B,EAAM0B,qBAAuB1B,EAAM0B,qBAAuBR,C,aCtDvE,IAAIlB,EAAQC,EAAQ,IAClBiB,EAAOjB,EAAQ,KAIjB,IAAIC,EAAW,oBAAsBC,OAAOC,GAAKD,OAAOC,GAHxD,SAAYC,EAAGC,GACb,OAAQD,IAAMC,IAAM,IAAMD,GAAK,EAAIA,IAAM,EAAIC,IAAQD,IAAMA,GAAKC,IAAMA,CACxE,EAEEoB,EAAuBR,EAAKQ,qBAC5BC,EAAS3B,EAAM2B,OACfnB,EAAYR,EAAMQ,UAClBoB,EAAU5B,EAAM4B,QAChBlB,EAAgBV,EAAMU,cACxBe,EAAQI,iCAAmC,SACzCP,EACAR,EACAgB,EACAC,EACAC,GAEA,IAAIC,EAAUN,EAAO,MACrB,GAAI,OAASM,EAAQC,QAAS,CAC5B,IAAItB,EAAO,CAAEuB,UAAU,EAAIpB,MAAO,MAClCkB,EAAQC,QAAUtB,CACpB,MAAOA,EAAOqB,EAAQC,QACtBD,EAAUL,EACR,WACE,SAASQ,EAAiBC,GACxB,IAAKC,EAAS,CAIZ,GAHAA,GAAU,EACVC,EAAmBF,EACnBA,EAAeN,EAASM,QACf,IAAML,GAAWpB,EAAKuB,SAAU,CACvC,IAAIK,EAAmB5B,EAAKG,MAC5B,GAAIiB,EAAQQ,EAAkBH,GAC5B,OAAQI,EAAoBD,CAChC,CACA,OAAQC,EAAoBJ,CAC9B,CAEA,GADAG,EAAmBC,EACfvC,EAASqC,EAAkBF,GAAe,OAAOG,EACrD,IAAIE,EAAgBX,EAASM,GAC7B,YAAS,IAAML,GAAWA,EAAQQ,EAAkBE,IAC1CH,EAAmBF,EAAeG,IAC5CD,EAAmBF,EACXI,EAAoBC,EAC9B,CACA,IACEH,EACAE,EAFEH,GAAU,EAGZK,OACO,IAAMb,EAAoB,KAAOA,EAC1C,MAAO,CACL,WACE,OAAOM,EAAiBtB,IAC1B,EACA,OAAS6B,OACA,EACL,WACE,OAAOP,EAAiBO,IAC1B,EAER,EACA,CAAC7B,EAAagB,EAAmBC,EAAUC,IAE7C,IAAIjB,EAAQW,EAAqBJ,EAAWW,EAAQ,GAAIA,EAAQ,IAShE,OARAzB,EACE,WACEI,EAAKuB,UAAW,EAChBvB,EAAKG,MAAQA,CACf,EACA,CAACA,IAEHL,EAAcK,GACPA,CACT,C,aCjFE6B,EAAOnB,QAAU,EAAjBmB,I,aCAAA,EAAOnB,QAAU,EAAjBmB,I,oHCMF,MAAM,oBAAEC,EAAmB,sBAAEC,GAA0B3C,QAE/C4C,eAAcA,GAAK5C,OAAO6C,UAK5B,SAAUC,EACdC,EACAC,GAEA,OAAO,SAAuBC,EAAMC,EAAMC,GACxC,OAAOJ,EAAYE,EAAGC,EAAGC,IAAUH,EAAYC,EAAGC,EAAGC,EACvD,CACF,CAOM,SAAUC,EACdC,GAEA,OAAO,SAAoBJ,EAAQC,EAAQC,GACzC,IAAKF,IAAMC,GAAkB,kBAAND,GAA+B,kBAANC,EAC9C,OAAOG,EAAcJ,EAAGC,EAAGC,GAG7B,MAAM,MAAEG,GAAUH,EAEZI,EAAUD,EAAME,IAAIP,GACpBQ,EAAUH,EAAME,IAAIN,GAE1B,GAAIK,GAAWE,EACb,OAAOF,IAAYL,GAAKO,IAAYR,EAGtCK,EAAMI,IAAIT,EAAGC,GACbI,EAAMI,IAAIR,EAAGD,GAEb,MAAMU,EAASN,EAAcJ,EAAGC,EAAGC,GAKnC,OAHAG,EAAMM,OAAOX,GACbK,EAAMM,OAAOV,GAENS,CACT,CACF,CAaM,SAAUE,EAAoBC,GAClC,OAAQpB,EAAoBoB,GAAmCC,OAAOpB,EAAsBmB,GAC9F,CAKO,MAAME,EAEXhE,OAAOgE,QAAU,EAAEF,EAAoBG,IAAuCrB,EAAesB,KAAKJ,EAAQG,IAKtG,SAAUE,EAAmBlB,EAAQC,GACzC,OAAOD,IAAMC,IAAOD,IAAMC,GAAKD,IAAMA,GAAKC,IAAMA,CAClD,CCnFA,MAIM,yBAAEkB,EAAwB,KAAEC,GAASrE,OAKrC,SAAUsE,EAAqBrB,EAAgBC,GACnD,OAAOD,EAAEsB,aAAerB,EAAEqB,YAAcC,EAAoB,IAAIC,WAAWxB,GAAI,IAAIwB,WAAWvB,GAChG,C,SAKgBwB,EAAezB,EAAUC,EAAUC,GACjD,IAAIwB,EAAQ1B,EAAE2B,OAEd,GAAI1B,EAAE0B,SAAWD,EACf,OAAO,EAGT,KAAOA,KAAU,GACf,IAAKxB,EAAM0B,OAAO5B,EAAE0B,GAAQzB,EAAEyB,GAAQA,EAAOA,EAAO1B,EAAGC,EAAGC,GACxD,OAAO,EAIX,OAAO,CACT,CAKM,SAAU2B,EAAkB7B,EAAaC,GAC7C,OACED,EAAEsB,aAAerB,EAAEqB,YAChBC,EACD,IAAIC,WAAWxB,EAAE8B,OAAQ9B,EAAE+B,WAAY/B,EAAEsB,YACzC,IAAIE,WAAWvB,EAAE6B,OAAQ7B,EAAE8B,WAAY9B,EAAEqB,YAG/C,CAKM,SAAUU,EAAchC,EAASC,GACrC,OAAOiB,EAAmBlB,EAAEiC,UAAWhC,EAAEgC,UAC3C,CAKM,SAAUC,EAAelC,EAAUC,GACvC,OAAOD,EAAEmC,OAASlC,EAAEkC,MAAQnC,EAAEoC,UAAYnC,EAAEmC,SAAWpC,EAAEqC,QAAUpC,EAAEoC,OAASrC,EAAEsC,QAAUrC,EAAEqC,KAC9F,CAKM,SAAUC,EAAkBvC,EAA4BC,GAC5D,OAAOD,IAAMC,CACf,C,SAKgBuC,EAAaxC,EAAkBC,EAAkBC,GAC/D,MAAMuC,EAAOzC,EAAEyC,KAEf,GAAIA,IAASxC,EAAEwC,KACb,OAAO,EAGT,IAAKA,EACH,OAAO,EAGT,MAAMC,EAAiB,IAAIC,MAAwBF,GAC7CG,EAAY5C,EAAE6C,UAEpB,IAAIC,EACAC,EACArB,EAAQ,EAGZ,MAAQoB,EAAUF,EAAUI,UACtBF,EAAQG,MADuB,CAKnC,MAAMC,EAAYjD,EAAE4C,UAEpB,IAAIM,GAAW,EACXC,EAAa,EAGjB,MAAQL,EAAUG,EAAUF,UACtBD,EAAQE,MADuB,CAKnC,GAAIP,EAAeU,GAAa,CAC9BA,IACA,QACF,CAEA,MAAMC,EAASP,EAAQnF,MACjB2F,EAASP,EAAQpF,MAEvB,GACEuC,EAAM0B,OAAOyB,EAAO,GAAIC,EAAO,GAAI5B,EAAO0B,EAAYpD,EAAGC,EAAGC,IACzDA,EAAM0B,OAAOyB,EAAO,GAAIC,EAAO,GAAID,EAAO,GAAIC,EAAO,GAAItD,EAAGC,EAAGC,GAClE,CACAiD,EAAWT,EAAeU,IAAc,EACxC,KACF,CAEAA,GACF,CAEA,IAAKD,EACH,OAAO,EAGTzB,GACF,CAEA,OAAO,CACT,CAKO,MAAM6B,EAAkBrC,E,SAKfsC,EAAgBxD,EAAeC,EAAeC,GAC5D,MAAMuD,EAAarC,EAAKpB,GAExB,IAAI0B,EAAQ+B,EAAW9B,OAEvB,GAAIP,EAAKnB,GAAG0B,SAAWD,EACrB,OAAO,EAOT,KAAOA,KAAU,GACf,IAAKgC,EAAgB1D,EAAGC,EAAGC,EAAOuD,EAAW/B,IAC3C,OAAO,EAIX,OAAO,CACT,C,SAKgBiC,EAAsB3D,EAAeC,EAAeC,GAClE,MAAMuD,EAAa7C,EAAoBZ,GAEvC,IAMIgB,EACA4C,EACAC,EARAnC,EAAQ+B,EAAW9B,OAEvB,GAAIf,EAAoBX,GAAG0B,SAAWD,EACpC,OAAO,EAWT,KAAOA,KAAU,GAAG,CAGlB,GAFAV,EAAWyC,EAAW/B,IAEjBgC,EAAgB1D,EAAGC,EAAGC,EAAOc,GAChC,OAAO,EAMT,GAHA4C,EAAczC,EAAyBnB,EAAGgB,GAC1C6C,EAAc1C,EAAyBlB,EAAGe,IAGvC4C,GAAeC,MACXD,IACCC,GACDD,EAAYE,eAAiBD,EAAYC,cACzCF,EAAYG,aAAeF,EAAYE,YACvCH,EAAYI,WAAaH,EAAYG,UAE1C,OAAO,CAEX,CAEA,OAAO,CACT,CAKM,SAAUC,EAA0BjE,EAAqBC,GAC7D,OAAOiB,EAAmBlB,EAAEkE,UAAWjE,EAAEiE,UAC3C,CAKM,SAAUC,EAAgBnE,EAAWC,GACzC,OAAOD,EAAEoE,SAAWnE,EAAEmE,QAAUpE,EAAEqE,QAAUpE,EAAEoE,KAChD,C,SAKgBC,EAAatE,EAAaC,EAAaC,GACrD,MAAMuC,EAAOzC,EAAEyC,KAEf,GAAIA,IAASxC,EAAEwC,KACb,OAAO,EAGT,IAAKA,EACH,OAAO,EAGT,MAAMC,EAAiB,IAAIC,MAAwBF,GAC7CG,EAAY5C,EAAEuE,SAEpB,IAAIzB,EACAC,EAGJ,MAAQD,EAAUF,EAAUI,UACtBF,EAAQG,MADuB,CAKnC,MAAMC,EAAYjD,EAAEsE,SAEpB,IAAIpB,GAAW,EACXC,EAAa,EAGjB,MAAQL,EAAUG,EAAUF,UACtBD,EAAQE,MADuB,CAKnC,IACGP,EAAeU,IACblD,EAAM0B,OAAOkB,EAAQnF,MAAOoF,EAAQpF,MAAOmF,EAAQnF,MAAOoF,EAAQpF,MAAOqC,EAAGC,EAAGC,GAClF,CACAiD,EAAWT,EAAeU,IAAc,EACxC,KACF,CAEAA,GACF,CAEA,IAAKD,EACH,OAAO,CAEX,CAEA,OAAO,CACT,CAKM,SAAU5B,EAAoBvB,EAAeC,GACjD,IAAIyB,EAAQ1B,EAAEsB,WAEd,GAAIrB,EAAEqB,aAAeI,GAAS1B,EAAE+B,aAAe9B,EAAE8B,WAC/C,OAAO,EAGT,KAAOL,KAAU,GACf,GAAI1B,EAAE0B,KAAWzB,EAAEyB,GACjB,OAAO,EAIX,OAAO,CACT,CAKM,SAAU8C,EAAaxE,EAAQC,GACnC,OACED,EAAEyE,WAAaxE,EAAEwE,UACdzE,EAAE0E,WAAazE,EAAEyE,UACjB1E,EAAE2E,WAAa1E,EAAE0E,UACjB3E,EAAE4E,OAAS3E,EAAE2E,MACb5E,EAAE6E,OAAS5E,EAAE4E,MACb7E,EAAE8E,WAAa7E,EAAE6E,UACjB9E,EAAE+E,WAAa9E,EAAE8E,QAExB,CAEA,SAASrB,EAAgB1D,EAAeC,EAAeC,EAAmBc,GACxE,QAvTkB,WAwTfA,GAzTgB,QAyTYA,GA1TZ,QA0TyCA,IACtDhB,EAAEgF,WAAY/E,EAAE+E,WAKfjE,EAAOd,EAAGe,IAAad,EAAM0B,OAAO5B,EAAEgB,GAAWf,EAAEe,GAAWA,EAAUA,EAAUhB,EAAGC,EAAGC,EACjG,CCzSA,MAYM+E,EAA4C,CAChD,sBAAsB,EACtB,uBAAuB,EACvB,8BAA8B,EAC9B,uBAAuB,EACvB,wBAAwB,EACxB,uBAAuB,EACvB,wBAAwB,EACxB,yBAAyB,EACzB,yBAAyB,EACzB,yBAAyB,EACzB,0BAA0B,EAC1B,2BAA2B,GAKvBC,EAAWnI,OAAO6C,UAAUsF,SAa5B,SAAUC,EAAwBC,GAgBf,IAhBsB,qBAC7C/D,EAAoB,eACpBI,EAAc,kBACdI,EAAiB,cACjBG,EAAa,eACbE,EAAc,kBACdK,EAAiB,aACjBC,EAAY,gBACZe,EAAe,gBACfC,EAAe,0BACfS,EAAyB,gBACzBE,EAAe,aACfG,EAAY,oBACZ/C,EAAmB,aACnBiD,EAAY,sBACZa,GACuBD,EAIvB,OAAO,SAAoBpF,EAAQC,EAAQC,GAEzC,GAAIF,IAAMC,EACR,OAAO,EAKT,GAAS,MAALD,GAAkB,MAALC,EACf,OAAO,EAGT,MAAMqF,SAActF,EAEpB,GAAIsF,WAAgBrF,EAClB,OAAO,EAGT,GAAa,WAATqF,EACF,MAAa,WAATA,EACK/B,EAAgBvD,EAAGC,EAAGC,GAGlB,aAAToF,GACK/C,EAAkBvC,EAAGC,EAAGC,GAOnC,MAAMqF,EAAcvF,EAAEuF,YAatB,GAAIA,IAAgBtF,EAAEsF,YACpB,OAAO,EAMT,GAAIA,IAAgBxI,OAClB,OAAOyG,EAAgBxD,EAAGC,EAAGC,GAK/B,GAAIyC,MAAM6C,QAAQxF,GAChB,OAAOyB,EAAezB,EAAGC,EAAGC,GAS9B,GAAIqF,IAAgBE,KAClB,OAAOzD,EAAchC,EAAGC,EAAGC,GAG7B,GAAIqF,IAAgBG,OAClB,OAAOvB,EAAgBnE,EAAGC,EAAGC,GAG/B,GAAIqF,IAAgBI,IAClB,OAAOnD,EAAaxC,EAAGC,EAAGC,GAG5B,GAAIqF,IAAgBK,IAClB,OAAOtB,EAAatE,EAAGC,EAAGC,GAK5B,MAAM2F,EAAMX,EAASjE,KAAKjB,GAE1B,GAjJa,kBAiJT6F,EACF,OAAO7D,EAAchC,EAAGC,EAAGC,GAK7B,GAlJgB,oBAkJZ2F,EACF,OAAO1B,EAAgBnE,EAAGC,EAAGC,GAG/B,GAzJY,iBAyJR2F,EACF,OAAOrD,EAAaxC,EAAGC,EAAGC,GAG5B,GAzJY,iBAyJR2F,EACF,OAAOvB,EAAatE,EAAGC,EAAGC,GAG5B,GA/Je,oBA+JX2F,EAIF,MAAyB,oBAAX7F,EAAE8F,MAAyC,oBAAX7F,EAAE6F,MAAuBtC,EAAgBxD,EAAGC,EAAGC,GAK/F,GAtJY,iBAsJR2F,EACF,OAAOrB,EAAaxE,EAAGC,EAAGC,GAK5B,GAjLc,mBAiLV2F,EACF,OAAO3D,EAAelC,EAAGC,EAAGC,GAI9B,GA1LkB,uBA0Ld2F,EACF,OAAOrC,EAAgBxD,EAAGC,EAAGC,GAG/B,GAAI+E,EAAiBY,GACnB,OAAOtE,EAAoBvB,EAAGC,EAAGC,GAGnC,GAnMqB,yBAmMjB2F,EACF,OAAOxE,EAAqBrB,EAAGC,EAAGC,GAGpC,GApMkB,sBAoMd2F,EACF,OAAOhE,EAAkB7B,EAAGC,EAAGC,GAMjC,GA5MgB,qBA4MZ2F,GAvMW,oBAuMYA,GAnMZ,oBAmMkCA,EAC/C,OAAO5B,EAA0BjE,EAAGC,EAAGC,GAGzC,GAAImF,EAAuB,CACzB,IAAIU,EAAuBV,EAAsBQ,GAEjD,IAAKE,EAAsB,CACzB,MAAMC,EFlLI,OADUrI,EEmLSqC,GFlLXrC,EAAMsI,OAAOC,kBAA0BC,EEoLrDH,IACFD,EAAuBV,EAAsBW,GAEjD,CAIA,GAAID,EACF,OAAOA,EAAqB/F,EAAGC,EAAGC,EAEtC,CF/LE,IAAsBvC,EE4MxB,OAAO,CACT,CACF,CC5OO,MAAMyI,EAAYC,IAKMA,EAAkB,CAAEC,QAAQ,IAK1BD,EAAkB,CAAEE,UAAU,IAMxBF,EAAkB,CACvDE,UAAU,EACVD,QAAQ,IAMkBD,EAAkB,CAC5CG,yBAA0BA,IAAMtF,IAMAmF,EAAkB,CAClDC,QAAQ,EACRE,yBAA0BA,IAAMtF,IAMEmF,EAAkB,CACpDE,UAAU,EACVC,yBAA0BA,IAAMtF,IAOQmF,EAAkB,CAC1DE,UAAU,EACVC,yBAA0BA,IAAMtF,EAChCoF,QAAQ,IAWJ,SAAUD,IAAiF,IAA7CI,EAAAC,UAAA/E,OAAA,QAAAwE,IAAAO,UAAA,GAAAA,UAAA,GAA2C,CAAC,EAC9F,MAAM,SACJH,GAAW,EACXC,yBAA0BG,EAA8B,YACxDC,EAAW,OACXN,GAAS,GACPG,EAEEI,ED2KF,SAAwCC,GAIZ,IAJmB,SACnDP,EAAQ,mBACRQ,EAAkB,OAClBT,GACgCQ,EAC5BD,EAAS,CACXxF,uBACAI,eAAgB6E,EAAS3C,EAA+BlC,EACxDI,oBACAG,cAAeA,EACfE,eAAgBA,EAChBK,kBAAmBA,EACnBC,aAAc8D,EAASzG,EAAmB2C,EAAqBmB,GAAgCnB,EAC/Fe,gBAAiBA,EACjBC,gBAAiB8C,EAAS3C,EAA+BH,EACzDS,0BAA2BA,EAC3BE,gBAAiBA,EACjBG,aAAcgC,EAASzG,EAAmByE,EAAqBX,GAAgCW,EAC/F/C,oBAAqB+E,EACjBzG,EAAmB0B,EAA4BoC,GAC/CpC,EACJiD,aAAcA,EACda,2BAAuBc,GAOzB,GAJIY,IACFF,EAAS9J,OAAOiK,OAAO,CAAC,EAAGH,EAAQE,EAAmBF,KAGpDN,EAAU,CACZ,MAAM9E,EAAiBtB,EAAiB0G,EAAOpF,gBACzCe,EAAerC,EAAiB0G,EAAOrE,cACvCgB,EAAkBrD,EAAiB0G,EAAOrD,iBAC1Cc,EAAenE,EAAiB0G,EAAOvC,cAE7CuC,EAAS9J,OAAOiK,OAAO,CAAC,EAAGH,EAAQ,CACjCpF,iBACAe,eACAgB,kBACAc,gBAEJ,CAEA,OAAOuC,CACT,CCvNiBI,CAAqCR,GAC9CS,EAAa/B,EAAyB0B,GD4NxC,IACJM,ECxNA,OD0OI,SAAuBC,GAAwF,IAAjF,SAAEb,EAAQ,WAAEW,EAAU,YAAEN,EAAW,OAAEhF,EAAM,OAAE0E,GAAoCc,EACnH,GAAIR,EACF,OAAO,SAAuB5G,EAAMC,GAClC,MAAM,MAAEI,GAAQkG,EAAW,IAAIc,aAAYlB,GAAS,KAAEmB,GAASV,IAE/D,OAAOM,EAAWlH,EAAGC,EAAG,CACtBI,QACAuB,SACA0F,OACAhB,UAEJ,EAGF,GAAIC,EACF,OAAO,SAAuBvG,EAAMC,GAClC,OAAOiH,EAAWlH,EAAGC,EAAG,CACtBI,MAAO,IAAIgH,QACXzF,SACA0F,UAAMnB,EACNG,UAEJ,EAGF,MAAMpG,EAAQ,CACZG,WAAO8F,EACPvE,SACA0F,UAAMnB,EACNG,UAGF,OAAO,SAAuBtG,EAAMC,GAClC,OAAOiH,EAAWlH,EAAGC,EAAGC,EAC1B,CACF,CC7QSqH,CAAc,CAAEhB,WAAUW,aAAYN,cAAahF,OAJ3C+E,EACXA,EAA+BO,ID2NnCC,EC1NqCD,ED4N9B,SACLlH,EACAC,EACAuH,EACAC,EACAC,EACAC,EACAzH,GAEA,OAAOiH,EAAQnH,EAAGC,EAAGC,EACvB,GCpOkEoG,UACpE,C,2CCpGA,IAAMsB,EAAY,WAA8F,QAAAC,EAAAnB,UAAA/E,OAAhEmG,EAAA,IAAAnF,MAAAkF,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAAD,EAAAC,GAAArB,UAAAqB,GAC9C,OAAQC,IACNF,EAAKG,QAAQC,IACQ,oBAARA,EACTA,EAAIF,GACKE,IACPA,EAAmCpJ,QAAUkJ,KAIvD,EAKMG,EAA4D/C,IAA0B,IAAzB,iBAAEgD,GAAiBhD,EAEpF,MAAMiD,GAAY/J,EAAAA,EAAAA,sBAChB8J,EAAiBlK,UACjBkK,EAAiB1K,YACjB0K,EAAiB1J,mBAInB,OAAO4J,EAAAA,EAAAA,KAAAC,EAAAA,SAAA,CAAGC,SAAAzL,OAAOwH,OAAO8D,MAoDnB,IAAMI,EAAN,cAAgC7L,EAAAA,UAUrC2I,WAAAA,CAAYmD,GA/Fd,IAAAC,EAgGIC,MAAMF,GACNG,KAAKC,iBAAmBlM,EAAAA,YACxBiM,KAAKE,aAAc,EAEnBF,KAAK3I,MAAQ,CACX8I,+BAAgCC,QAAS,OAAAN,EAAAD,EAAMQ,aAAN,EAAAP,EAAoDP,kBAEjG,CAEAe,iBAAAA,GACEN,KAAKO,MACP,CAEAC,kBAAAA,GACER,KAAKO,MACP,CAEAA,IAAAA,GAjHF,IAAAT,EAkHI,MAAMO,EAASL,KAAKH,MAAMQ,OAE1B,GAAIA,IAAWA,EAAOI,cAAe,OAAAX,EAAAO,EAAOK,KAAKC,UAAZ,EAAAb,EAAiBc,YAAY,CAChE,GAAIP,EAAOd,iBACT,OAGF,MAAMsB,EAAUb,KAAKC,iBAAiBhK,QAEtC4K,EAAQC,UAAUT,EAAOK,KAAKC,IAAIC,WAAWG,YAE7CV,EAAOW,WAAW,CAChBH,YAGFR,EAAOd,iBAxFb,WACE,MAAM0B,EAAc,IAAIlE,IACxB,IAAIyC,EAA+C,CAAC,EAEpD,MAAO,CAILnK,UAAU6L,IACRD,EAAYE,IAAID,GACT,KACLD,EAAYnJ,OAAOoJ,KAGvBrM,YAAW,IACF2K,EAET3J,kBAAiB,IACR2J,EAKT4B,WAAAA,CAAYC,EAAYC,GACtB9B,GAAA+B,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACK/B,GAAA,IACH,CAAC6B,GAAKG,EAAAA,aAAsBF,EAASG,aAAcH,EAAST,QAASQ,KAGvEJ,EAAY7B,QAAQsC,GAAcA,IACpC,EAIAC,cAAAA,CAAeN,GACb,MAAMO,GAAAL,EAAAA,EAAAA,GAAA,GAAqB/B,UAEpBoC,EAAcP,GACrB7B,EAAYoC,EACZX,EAAY7B,QAAQsC,GAAcA,IACpC,EAEJ,CA8CgCG,GAGrB7B,KAAK3I,MAAM8I,iCAEdH,KAAK8B,8BAAgCzB,EAAOd,iBAAiBlK,UAAU,KACrE2K,KAAK+B,SAASC,GACPA,EAAU7B,+BAKR6B,EAJE,CACL7B,gCAAgC,IAOlCH,KAAK8B,+BACP9B,KAAK8B,mCAKXzB,EAAO4B,kBAEPjC,KAAKE,aAAc,CACrB,CACF,CAEAgC,oBAAAA,GA7JF,IAAApC,EA8JI,MAAMO,EAASL,KAAKH,MAAMQ,OAE1B,GAAKA,EAAL,CAIAL,KAAKE,aAAc,EAEdG,EAAOI,aACVJ,EAAOK,KAAKyB,SAAS,CACnBC,UAAW,CAAC,IAIZpC,KAAK8B,+BACP9B,KAAK8B,gCAGPzB,EAAOd,iBAAmB,KAI1B,IACE,KAAK,OAAAO,EAAAO,EAAOK,KAAKC,UAAZ,EAAAb,EAAiBc,YACpB,OAIF,MAAMyB,EAAalN,SAASC,cAAc,OAE1CiN,EAAWvB,UAAUT,EAAOK,KAAKC,IAAIC,WAAWG,YAEhDV,EAAOW,WAAW,CAChBH,QAASwB,GAEb,CAAE,MAAFC,GAEA,CAjCA,CAkCF,CAEAC,MAAAA,GACE,MAAAC,EAAsCxC,KAAKH,OAArC,OAAEQ,EAAA,SAAQoC,GAAkBD,EAALE,GAAAC,EAAAA,EAAAA,GAAAH,EAAAI,GAE7B,OACEC,EAAAA,EAAAA,MAAAnD,EAAAA,SAAA,CACEC,SAAA,EAAAF,EAAAA,EAAAA,KAAC,OAAA8B,EAAAA,EAAAA,GAAA,CAAIlC,IAAKN,EAAU0D,EAAUzC,KAAKC,mBAAuByC,KAEzD,MAAArC,OAAA,EAAAA,EAAQd,oBAAoBE,EAAAA,EAAAA,KAACH,EAAA,CAAQC,iBAAkBc,EAAOd,qBAGrE,GAIIuD,GAAuBC,EAAAA,EAAAA,YAC3B,CAAClD,EAA6CR,KAC5C,MAAM2D,EAAMjP,EAAAA,QAAc,IACjBkP,KAAKC,MAAsB,WAAhBD,KAAKE,UAAuB9G,WAE7C,CAACwD,EAAMQ,SAGV,OAAOtM,EAAAA,cAAoB6L,GAAA2B,EAAAA,EAAAA,GAAA,CACzByB,MACAP,SAAUpD,GACPQ,MAKIuD,EAAgBrP,EAAAA,KAAW+O,GC/NlCO,EAA8C,qBAAXnO,OAAyBV,EAAAA,gBAAkBD,EAAAA,UA2B9E+O,EAAN,MAWE5G,WAAAA,CAAY6G,GAVZ,KAAQC,kBAAoB,EAE5B,KAAQC,sBAAwB,EAMhC,KAAQxC,YAAc,IAAIlE,IAGxBiD,KAAKK,OAASkD,EACdvD,KAAK0D,aAAe,CAAErD,OAAQkD,EAAeC,kBAAmB,GAEhExD,KAAKnL,YAAcmL,KAAKnL,YAAY8O,KAAK3D,MACzCA,KAAKnK,kBAAoBmK,KAAKnK,kBAAkB8N,KAAK3D,MACrDA,KAAK4D,MAAQ5D,KAAK4D,MAAMD,KAAK3D,MAC7BA,KAAK3K,UAAY2K,KAAK3K,UAAUsO,KAAK3D,KACvC,CAKAnL,WAAAA,GACE,OAAImL,KAAKwD,oBAAsBxD,KAAKyD,wBAGpCzD,KAAKyD,sBAAwBzD,KAAKwD,kBAClCxD,KAAK0D,aAAe,CAAErD,OAAQL,KAAKK,OAAQmD,kBAAmBxD,KAAKwD,oBAH1DxD,KAAK0D,YAKhB,CAKA7N,iBAAAA,GACE,MAAO,CAAEwK,OAAQ,KAAMmD,kBAAmB,EAC5C,CAKAnO,SAAAA,CAAU6L,GAER,OADAlB,KAAKiB,YAAYE,IAAID,GACd,KACLlB,KAAKiB,YAAYnJ,OAAOoJ,GAE5B,CAKA0C,KAAAA,CAAMC,GAGJ,GAFA7D,KAAKK,OAASwD,EAEV7D,KAAKK,OAAQ,CAMf,MAAMyD,EAAKA,KACT9D,KAAKwD,mBAAqB,EAC1BxD,KAAKiB,YAAY7B,QAAQ8B,GAAYA,MAGjC6C,EAAgB/D,KAAKK,OAG3B,OADA0D,EAAcC,GAAG,cAAeF,GACzB,KACLC,EAAcE,IAAI,cAAeH,GAErC,CAGF,GA2CK,SAASI,EACdtG,GAxJF,IAAAkC,EA0JE,MAAOqE,IAAsB7P,EAAAA,EAAAA,UAAS,IAAM,IAAIgP,EAAmB1F,EAAQyC,SAGrE+D,GAAgBxO,EAAAA,EAAAA,kCACpBuO,EAAmB9O,UACnB8O,EAAmBtP,YACnBsP,EAAmBtO,kBACnB+H,EAAQ9H,SACR,OAAAgK,EAAAlC,EAAQyG,YAARvE,EAAsBvC,GASxB,OANA8F,EAA0B,IACjBc,EAAmBP,MAAMhG,EAAQyC,QACvC,CAACzC,EAAQyC,OAAQ8D,KAEpB1P,EAAAA,EAAAA,eAAc2P,GAEPA,CACT,CCpKA,IACME,EAA0B,qBAAXpP,OACfqP,EAASD,GAASlE,QAA0B,qBAAXlL,QAA2BA,OAAeiF,MAwB3EqK,EAAN,MAAMC,EAqCJ/H,WAAAA,CAAYkB,GAjCZ,KAAQyC,OAAwB,KAWhC,KAAQqE,cAAgB,IAAI3H,IAU5B,KAAQ4H,oBAAqB,EAK7B,KAAQC,aAAsC,KAK9C,KAAOC,WAAa,GAGlB7E,KAAKpC,QAAUA,EACfoC,KAAK0E,cAAgB,IAAI3H,IACzBiD,KAAK8E,UAAU9E,KAAK+E,oBACpB/E,KAAKgF,kBAELhF,KAAKiF,UAAYjF,KAAKiF,UAAUtB,KAAK3D,MACrCA,KAAKnK,kBAAoBmK,KAAKnK,kBAAkB8N,KAAK3D,MACrDA,KAAK3K,UAAY2K,KAAK3K,UAAUsO,KAAK3D,MACrCA,KAAKkF,sBAAwBlF,KAAKkF,sBAAsBvB,KAAK3D,MAC7DA,KAAKgF,gBAAkBhF,KAAKgF,gBAAgBrB,KAAK3D,MACjDA,KAAKmF,SAAWnF,KAAKmF,SAASxB,KAAK3D,MACnCA,KAAKoF,aAAepF,KAAKoF,aAAazB,KAAK3D,KAC7C,CAEQ8E,SAAAA,CAAUzE,GAChBL,KAAKK,OAASA,EACdL,KAAK6E,WAAa5B,KAAKE,SAAS9G,SAAS,IAAIgJ,MAAM,EAAG,GAGtDrF,KAAK0E,cAActF,QAAQkG,GAAMA,IACnC,CAEQP,gBAAAA,GACN,YAA+C,IAA3C/E,KAAKpC,QAAQ3H,QAAQsP,kBACnBjB,GAASC,EAYJ,KAIFvE,KAAKoF,gBAGVpF,KAAKpC,QAAQ3H,QAAQsP,kBAOrBvF,KAAKpC,QAAQ3H,QAAQsP,kBAChBvF,KAAKoF,eAGP,KACT,CAKQA,YAAAA,GAAuB,IAAAI,EAAA,KAC7B,MAAMC,GAAAlE,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACDvB,KAAKpC,QAAQ3H,SAAA,IAEhByP,eAAgB,WAxItB,QAAA5F,EAAA6F,EAAAC,EAAA/H,UAAA/E,OAwI0B+M,EAAA,IAAA/L,MAAA8L,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAAD,EAAAC,GAAAjI,UAAAiI,GAAS,cAAAH,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQyP,qBAArB,EAAAC,EAAAvN,KAAA0H,KAAyC+F,EAAA,EACtEE,OAAQ,WAzId,QAAAjG,EAAA6F,EAAAK,EAAAnI,UAAA/E,OAyIkB+M,EAAA,IAAA/L,MAAAkM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAJ,EAAAI,GAAApI,UAAAoI,GAAS,cAAAN,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQ8P,aAArB,EAAAJ,EAAAvN,KAAA0H,KAAiC+F,EAAA,EACtDK,SAAU,WA1IhB,QAAApG,EAAA6F,EAAAQ,EAAAtI,UAAA/E,OA0IoB+M,EAAA,IAAA/L,MAAAqM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAP,EAAAO,GAAAvI,UAAAuI,GAAS,cAAAT,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQiQ,eAArB,EAAAP,EAAAvN,KAAA0H,KAAmC+F,EAAA,EAC1DQ,UAAW,WA3IjB,QAAAvG,EAAA6F,EAAAW,EAAAzI,UAAA/E,OA2IqB+M,EAAA,IAAA/L,MAAAwM,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAV,EAAAU,GAAA1I,UAAA0I,GAAS,cAAAZ,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQoQ,gBAArB,EAAAV,EAAAvN,KAAA0H,KAAoC+F,EAAA,EAC5DW,QAAS,WA5If,QAAA1G,EAAA6F,EAAAc,EAAA5I,UAAA/E,OA4ImB+M,EAAA,IAAA/L,MAAA2M,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAb,EAAAa,GAAA7I,UAAA6I,GAAS,cAAAf,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQuQ,cAArB,EAAAb,EAAAvN,KAAA0H,KAAkC+F,EAAA,EACxDc,kBAAmB,WA7IzB,QAAA7G,EAAA6F,EAAAiB,EAAA/I,UAAA/E,OA6I6B+M,EAAA,IAAA/L,MAAA8M,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAhB,EAAAgB,GAAAhJ,UAAAgJ,GAAS,cAAAlB,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQ0Q,wBAArB,EAAAhB,EAAAvN,KAAA0H,KAA4C+F,EAAA,EAC5EiB,cAAe,WA9IrB,QAAAhH,EAAA6F,EAAAoB,EAAAlJ,UAAA/E,OA8IyB+M,EAAA,IAAA/L,MAAAiN,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAnB,EAAAmB,GAAAnJ,UAAAmJ,GAAS,cAAArB,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQ6Q,oBAArB,EAAAnB,EAAAvN,KAAA0H,KAAwC+F,EAAA,EACpEoB,SAAU,WA/IhB,QAAAnH,EAAA6F,EAAAuB,EAAArJ,UAAA/E,OA+IoB+M,EAAA,IAAA/L,MAAAoN,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAtB,EAAAsB,GAAAtJ,UAAAsJ,GAAS,cAAAxB,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQgR,eAArB,EAAAtB,EAAAvN,KAAA0H,KAAmC+F,EAAA,EAC1DuB,eAAgB,WAhJtB,QAAAtH,EAAA6F,EAAA0B,EAAAxJ,UAAA/E,OAgJ0B+M,EAAA,IAAA/L,MAAAuN,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAzB,EAAAyB,GAAAzJ,UAAAyJ,GAAS,cAAA3B,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQmR,qBAArB,EAAAzB,EAAAvN,KAAA0H,KAAyC+F,EAAA,EACtE0B,OAAQ,WAjJd,QAAAzH,EAAA6F,EAAA6B,EAAA3J,UAAA/E,OAiJkB+M,EAAA,IAAA/L,MAAA0N,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA5B,EAAA4B,GAAA5J,UAAA4J,GAAS,cAAA9B,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQsR,aAArB,EAAA5B,EAAAvN,KAAA0H,KAAiC+F,EAAA,EACtD6B,QAAS,WAlJf,QAAA5H,EAAA6F,EAAAgC,EAAA9J,UAAA/E,OAkJmB+M,EAAA,IAAA/L,MAAA6N,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAA/B,EAAA+B,GAAA/J,UAAA+J,GAAS,cAAAjC,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQyR,cAArB,EAAA/B,EAAAvN,KAAA0H,KAAkC+F,EAAA,EACxDgC,SAAU,WAnJhB,QAAA/H,EAAA6F,EAAAmC,EAAAjK,UAAA/E,OAmJoB+M,EAAA,IAAA/L,MAAAgO,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAAlC,EAAAkC,GAAAlK,UAAAkK,GAAS,cAAApC,GAAA7F,EAAA0F,EAAK5H,QAAQ3H,SAAQ4R,eAArB,EAAAlC,EAAAvN,KAAA0H,KAAmC+F,EAAA,IAM5D,OAJe,IAAImC,EAAAA,GAAOvC,EAK5B,CAKAR,SAAAA,GACE,OAAOjF,KAAKK,MACd,CAKAxK,iBAAAA,GACE,OAAO,IACT,CAKAR,SAAAA,CAAU4S,GAGR,OAFAjI,KAAK0E,cAAcvD,IAAI8G,GAEhB,KACLjI,KAAK0E,cAAc5M,OAAOmQ,GAE9B,CAEA,qBAAOC,CAAe/Q,EAAqBC,GACzC,OAAQlD,OAAOqE,KAAKpB,GAAkCgR,MAAMnF,KAExD,CACE,WACA,iBACA,YACA,WACA,gBACA,UACA,SACA,oBACA,iBACA,SACA,WACAoF,SAASpF,KAOD,eAARA,GAAwB7L,EAAEkR,YAAcjR,EAAEiR,WACxClR,EAAEkR,WAAWvP,SAAW1B,EAAEiR,WAAWvP,QAGlC3B,EAAEkR,WAAWF,MAAM,CAACG,EAAWzP,KA/M9C,IAAAiH,EAgNU,OAAIwI,KAAc,OAAAxI,EAAA1I,EAAEiR,iBAAF,EAAAvI,EAAejH,MAMjC1B,EAAE6L,KAAS5L,EAAE4L,IAMrB,CAOAmC,QAAAA,CAASoD,GAEP,MAAO,KACLvI,KAAK2E,oBAAqB,EAE1B6D,aAAaxI,KAAKyI,6BAEdzI,KAAKK,SAAWL,KAAKK,OAAOI,aAA+B,IAAhB8H,EAAKzP,OAE7C2L,EAAsByD,eAAelI,KAAKpC,QAAQ3H,QAAS+J,KAAKK,OAAOzC,UAG1EoC,KAAKK,OAAOW,YAAAO,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACPvB,KAAKpC,QAAQ3H,SAAA,IAChByS,SAAU1I,KAAKK,OAAOsI,cAS1B3I,KAAKkF,sBAAsBqD,GAGtB,KACLvI,KAAK2E,oBAAqB,EAC1B3E,KAAKgF,mBAGX,CAKQE,qBAAAA,CAAsBqD,GAC5B,GAAIvI,KAAKK,SAAWL,KAAKK,OAAOI,YAAa,CAE3C,GAA0B,OAAtBT,KAAK4E,aAGP,YADA5E,KAAK4E,aAAe2D,GAMtB,GAFEvI,KAAK4E,aAAa9L,SAAWyP,EAAKzP,QAAUkH,KAAK4E,aAAauD,MAAM,CAACS,EAAK/P,IAAU+P,IAAQL,EAAK1P,IAIjG,MAEJ,CAEImH,KAAKK,SAAWL,KAAKK,OAAOI,aAE9BT,KAAKK,OAAOwI,UAGd7I,KAAK8E,UAAU9E,KAAKoF,gBAGpBpF,KAAK4E,aAAe2D,CACtB,CAOQvD,eAAAA,GACN,MAAM8D,EAAoB9I,KAAK6E,WACzBd,EAAgB/D,KAAKK,OAG3BL,KAAKyI,4BAA8BM,WAAW,KACxC/I,KAAK2E,oBAAsB3E,KAAK6E,aAAeiE,EAE7C/E,GAEFA,EAAc/C,WAAWhB,KAAKpC,QAAQ3H,SAItC8N,IAAkBA,EAActD,cAClCsD,EAAc8E,UACV7I,KAAK6E,aAAeiE,GACtB9I,KAAK8E,UAAU,QAKlB,EACL,GAwBK,SAASkE,KAAoF,IAA1EpL,EAAAC,UAAA/E,OAAA,QAAAwE,IAAAO,UAAA,GAAAA,UAAA,GAA4B,CAAC,EAAG0K,EAAA1K,UAAA/E,OAAA,QAAAwE,IAAAO,UAAA,GAAAA,UAAA,GAAuB,GAC/E,MAAMoL,GAAoBvT,EAAAA,EAAAA,QAAOkI,GAEjCqL,EAAkBhT,QAAU2H,EAE5B,MAAOsL,IAAmBC,EAAAA,EAAAA,UAAS,IAAM,IAAI3E,EAAsByE,IAE7D5I,GAAS+I,EAAAA,EAAAA,sBACbF,EAAgB7T,UAChB6T,EAAgBjE,UAChBiE,EAAgBrT,mBA2BlB,OAxBAwT,EAAAA,EAAAA,eAAchJ,IAIdiJ,EAAAA,EAAAA,WAAUJ,EAAgB/D,SAASoD,IAInCrE,EAAe,CACb7D,SACAvK,SAAUmI,IAA2B,IAA1B,kBAAEuF,GAAkBvF,EAC7B,OAA4C,IAAxCL,EAAQ2L,kCAAiF,IAAxC3L,EAAQ2L,4BAEpD,KAIL3L,EAAQ2H,mBAA2C,IAAtB/B,EACxB,EAEFA,EAAoB,KAIxBnD,CACT,CCjXO,IAAMmJ,IAAgBC,EAAAA,EAAAA,eAAkC,CAC7DpJ,OAAQ,OAGoBmJ,GAAcE,SCHrC,IAAMC,IAAuBC,EAAAA,EAAAA,eAAyC,CAC3EC,YAAaA,OAGbC,6BAAyB,EACzBC,mBAAoBA,SASTC,GAAmBA,KAAMC,EAAAA,EAAAA,YAAWN,IClBcO,EAAAA,WAAiB,CAACrK,EAAOR,KACtF,MAAM,YAAEwK,GAAgBG,KAClBG,EAAMtK,EAAMuK,IAAM,MAExB,OAEEC,EAAAA,EAAAA,KAACF,GAAA5I,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACK1B,GAAA,IACJR,MACA,yBAAuB,GACvBwK,cACAS,OAAA/I,EAAAA,EAAAA,GAAA,CACEgJ,WAAY,UACT1K,EAAMyK,YCHjB,SAASE,GAAiBC,GACxB,QAA+B,oBAAdA,IAA4BA,EAAU1T,YAAa0T,EAAU1T,UAAU2T,iBAC1F,CAOA,SAASC,GAAsBF,GAC7B,QACuB,kBAAdA,IACPA,EAAUtO,UACyB,8BAAlCsO,EAAUtO,SAASE,YACiB,sBAAnCoO,EAAUtO,SAASyO,YAEzB,CA+GO,IAAMC,GAAN,MAuBLnO,WAAAA,CACEoO,EAAAC,GAEA,IADA,OAAE1K,EAAA,MAAQR,EAAQ,CAAC,EAAC,GAAEuK,EAAK,gBAAOY,EAAY,IAAGD,EAZnD,KAAA1L,IAAgB,KAKhB,KAAA4L,WAAY,EASVjL,KAAKqB,GAAK4B,KAAKC,MAAsB,WAAhBD,KAAKE,UAAuB9G,WACjD2D,KAAK8K,UAAYA,EACjB9K,KAAKK,OAASA,EACdL,KAAKH,MAAQA,EACbG,KAAKa,QAAU1L,SAASC,cAAcgV,GACtCpK,KAAKa,QAAQqK,UAAU/J,IAAI,kBAEvB6J,GACFhL,KAAKa,QAAQqK,UAAU/J,OAAO6J,EAAUG,MAAM,MAM5CnL,KAAKK,OAAO+K,eACdC,EAAAA,EAAAA,WAAU,KACRrL,KAAKuC,WAGP+I,eAAe,KACTtL,KAAKiL,WAGTjL,KAAKuC,UAGX,CAKAA,MAAAA,GA5MF,IAAAzC,EA6MI,GAAIE,KAAKiL,UACP,OAGF,MAAMR,EAAYzK,KAAK8K,UACjBjL,EAAQG,KAAKH,MACbQ,EAASL,KAAKK,OAGdkL,EAlIV,WAIE,IAEE,GAAIC,EAAAA,QAEF,OADqBC,SAASD,EAAAA,QAAaL,MAAM,KAAK,GAAI,KACnC,EAE3B,CAAE,MAAFO,GAEA,CACA,OAAO,CACT,CAoHsBC,GACZC,EA9JV,SAAuBnB,GAErB,GAAID,GAAiBC,GACnB,OAAO,EAIT,GAAIE,GAAsBF,GACxB,OAAO,EAIT,GA3BF,SAAyBA,GACvB,QACuB,kBAAdA,IACPA,EAAUtO,UACyB,uBAAlCsO,EAAUtO,SAASE,YAA0E,eAAnCoO,EAAUtO,SAASyO,YAElF,CAqBMiB,CAAgBpB,GAAY,CAE9B,MAAMqB,EAAmBrB,EAAUhO,KACnC,GAAIqP,EACF,OAAOtB,GAAiBsB,IAAqBnB,GAAsBmB,EAEvE,CAEA,OAAO,CACT,CAyImCC,CAActB,GAEvCuB,GAAAzK,EAAAA,EAAAA,GAAA,GAAoB1B,IAGtBmM,EAAa3M,KAASkM,GAAaK,UAC9BI,EAAa3M,IAIjB2M,EAAa3M,MAAQkM,IAAaK,IAErCI,EAAa3M,IAAOA,IAClBW,KAAKX,IAAMA,IAIfW,KAAKyB,cAAewK,EAAAA,EAAAA,KAACxB,GAAAlJ,EAAAA,EAAAA,GAAA,GAAcyK,IAEnC,OAAAlM,EAAA,MAAAO,OAAA,EAAAA,EAAQd,mBAARO,EAA0BsB,YAAYpB,KAAKqB,GAAIrB,KACjD,CAKAkM,WAAAA,GAAmD,IAAvCrM,EAAAhC,UAAA/E,OAAA,QAAAwE,IAAAO,UAAA,GAAAA,UAAA,GAA6B,CAAC,EACpCmC,KAAKiL,YAITjL,KAAKH,OAAA0B,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACAvB,KAAKH,OACLA,GAGLG,KAAKuC,SACP,CAKAsG,OAAAA,GAhQF,IAAA/I,EAiQIE,KAAKiL,WAAY,EACjB,MAAM5K,EAASL,KAAKK,OAEpB,OAAAP,EAAA,MAAAO,OAAA,EAAAA,EAAQd,mBAARO,EAA0B6B,eAAe3B,KAAKqB,IAI9C,IACMrB,KAAKa,SAAWb,KAAKa,QAAQD,YAC/BZ,KAAKa,QAAQD,WAAWuL,YAAYnM,KAAKa,QAE7C,CAAE,MAAFuL,GAEA,CACF,CAKAC,gBAAAA,CAAiBC,GACfpY,OAAOqE,KAAK+T,GAAYlN,QAAQ4D,IAC9BhD,KAAKa,QAAQ0L,aAAavJ,EAAKsJ,EAAWtJ,KAE9C,GC7QWwJ,GAAuBC,EAAAA,cAA0C,CAC5EC,mBAAoBA,SA8BaC,EAAAA,GCgBzBC,EAAAA,GClCH,IAAMC,IAAgBC,EAAAA,EAAAA,eAAiC,CAC5D,UAAIzM,GACF,MAAM,IAAI0M,MAAM,oDAClB,IAGFF,GAAcG,YAAc,gBAyBrB,IAAMC,GAAYA,KAAMC,EAAAA,EAAAA,YAAWL,IAqFnC,SAASM,GAAAC,GAAkE,IAApD,OAAE/M,EAAA,SAAQgN,EAAA,SAAU1N,GAASyN,EACzD,MAAME,EAAiB,MAAAjN,EAAAA,EAAUgN,EAEjC,IAAKC,EACH,MAAM,IAAIP,MAAM,0EAGlB,MAAMQ,GAAqBC,EAAAA,EAAAA,SAA2B,KAAM,CAAGnN,OAAQiN,IAAmB,CAACA,IAIrFG,GAAqBD,EAAAA,EAAAA,SAAQ,KAAM,CAAGnN,OAAQiN,IAAmB,CAACA,IAExE,OACEI,EAAAA,EAAAA,KAAClE,GAAcmE,SAAd,CAAuB7Y,MAAO2Y,EAC7B9N,UAAA+N,EAAAA,EAAAA,KAACb,GAAcc,SAAd,CAAuB7Y,MAAOyY,EAAqB5N,cAG1D,CAiBO,SAASiO,GAAAC,GAAuE,IAApDnL,EAAAxO,OAAAiK,OAAA,IC/KnC,SAAmC2P,GACjC,GAAI,MAAQA,EAAG,MAAM,IAAIC,UAAU,sBAAwBD,EAC7D,CD6KmCE,CAAAH,GAAAA,IACjC,MAAM,OAAExN,GAAW4M,KAEnB,OAAOS,EAAAA,EAAAA,KAACtK,GAAA7B,EAAAA,EAAAA,GAAA,CAAclB,UAAoBqC,GAC5C,CAnBAyK,GAAcH,YAAc,SAqB5BY,GAAcZ,YAAc,iBAkCN9Y,OAAOiK,OAAOgP,GAAe,CAKjDc,QAASL,I","sources":["../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js","../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js","../node_modules/use-sync-external-store/shim/index.js","../node_modules/use-sync-external-store/shim/with-selector.js","../node_modules/@tiptap/react/node_modules/src/utils.ts","../node_modules/@tiptap/react/node_modules/src/equals.ts","../node_modules/@tiptap/react/node_modules/src/comparator.ts","../node_modules/@tiptap/react/node_modules/src/index.ts","../node_modules/@tiptap/react/src/EditorContent.tsx","../node_modules/@tiptap/react/src/useEditorState.ts","../node_modules/@tiptap/react/src/useEditor.ts","../node_modules/@tiptap/react/src/Context.tsx","../node_modules/@tiptap/react/src/useReactNodeView.ts","../node_modules/@tiptap/react/src/NodeViewWrapper.tsx","../node_modules/@tiptap/react/src/ReactRenderer.tsx","../node_modules/@tiptap/react/src/ReactMarkViewRenderer.tsx","../node_modules/@tiptap/react/src/ReactNodeViewRenderer.tsx","../node_modules/@tiptap/react/src/Tiptap.tsx","../node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js"],"sourcesContent":["/**\n * @license React\n * use-sync-external-store-shim.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useState = React.useState,\n  useEffect = React.useEffect,\n  useLayoutEffect = React.useLayoutEffect,\n  useDebugValue = React.useDebugValue;\nfunction useSyncExternalStore$2(subscribe, getSnapshot) {\n  var value = getSnapshot(),\n    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),\n    inst = _useState[0].inst,\n    forceUpdate = _useState[1];\n  useLayoutEffect(\n    function () {\n      inst.value = value;\n      inst.getSnapshot = getSnapshot;\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n    },\n    [subscribe, value, getSnapshot]\n  );\n  useEffect(\n    function () {\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      return subscribe(function () {\n        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      });\n    },\n    [subscribe]\n  );\n  useDebugValue(value);\n  return value;\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction useSyncExternalStore$1(subscribe, getSnapshot) {\n  return getSnapshot();\n}\nvar shim =\n  \"undefined\" === typeof window ||\n  \"undefined\" === typeof window.document ||\n  \"undefined\" === typeof window.document.createElement\n    ? useSyncExternalStore$1\n    : useSyncExternalStore$2;\nexports.useSyncExternalStore =\n  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\"),\n  shim = require(\"use-sync-external-store/shim\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useSyncExternalStore = shim.useSyncExternalStore,\n  useRef = React.useRef,\n  useEffect = React.useEffect,\n  useMemo = React.useMemo,\n  useDebugValue = React.useDebugValue;\nexports.useSyncExternalStoreWithSelector = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot,\n  selector,\n  isEqual\n) {\n  var instRef = useRef(null);\n  if (null === instRef.current) {\n    var inst = { hasValue: !1, value: null };\n    instRef.current = inst;\n  } else inst = instRef.current;\n  instRef = useMemo(\n    function () {\n      function memoizedSelector(nextSnapshot) {\n        if (!hasMemo) {\n          hasMemo = !0;\n          memoizedSnapshot = nextSnapshot;\n          nextSnapshot = selector(nextSnapshot);\n          if (void 0 !== isEqual && inst.hasValue) {\n            var currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSnapshot))\n              return (memoizedSelection = currentSelection);\n          }\n          return (memoizedSelection = nextSnapshot);\n        }\n        currentSelection = memoizedSelection;\n        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n        var nextSelection = selector(nextSnapshot);\n        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n          return (memoizedSnapshot = nextSnapshot), currentSelection;\n        memoizedSnapshot = nextSnapshot;\n        return (memoizedSelection = nextSelection);\n      }\n      var hasMemo = !1,\n        memoizedSnapshot,\n        memoizedSelection,\n        maybeGetServerSnapshot =\n          void 0 === getServerSnapshot ? null : getServerSnapshot;\n      return [\n        function () {\n          return memoizedSelector(getSnapshot());\n        },\n        null === maybeGetServerSnapshot\n          ? void 0\n          : function () {\n              return memoizedSelector(maybeGetServerSnapshot());\n            }\n      ];\n    },\n    [getSnapshot, getServerSnapshot, selector, isEqual]\n  );\n  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n  useEffect(\n    function () {\n      inst.hasValue = !0;\n      inst.value = value;\n    },\n    [value]\n  );\n  useDebugValue(value);\n  return value;\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import type {\n  AnyEqualityComparator,\n  Cache,\n  CircularState,\n  Dictionary,\n  State,\n  TypeEqualityComparator,\n} from './internalTypes.js';\n\nconst { getOwnPropertyNames, getOwnPropertySymbols } = Object;\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * Combine two comparators into a single comparators.\n */\nexport function combineComparators<Meta>(\n  comparatorA: AnyEqualityComparator<Meta>,\n  comparatorB: AnyEqualityComparator<Meta>,\n) {\n  return function isEqual<A, B>(a: A, b: B, state: State<Meta>) {\n    return comparatorA(a, b, state) && comparatorB(a, b, state);\n  };\n}\n\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nexport function createIsCircular<AreItemsEqual extends TypeEqualityComparator<any, any>>(\n  areItemsEqual: AreItemsEqual,\n): AreItemsEqual {\n  return function isCircular(a: any, b: any, state: CircularState<Cache<any, any>>) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, state);\n    }\n\n    const { cache } = state;\n\n    const cachedA = cache.get(a);\n    const cachedB = cache.get(b);\n\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n\n    cache.set(a, b);\n    cache.set(b, a);\n\n    const result = areItemsEqual(a, b, state);\n\n    cache.delete(a);\n    cache.delete(b);\n\n    return result;\n  } as AreItemsEqual;\n}\n\n/**\n * Get the `@@toStringTag` of the value, if it exists.\n */\nexport function getShortTag(value: any): string | undefined {\n  return value != null ? (value[Symbol.toStringTag] as string) : undefined;\n}\n\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nexport function getStrictProperties(object: Dictionary): Array<string | symbol> {\n  return (getOwnPropertyNames(object) as Array<string | symbol>).concat(getOwnPropertySymbols(object));\n}\n\n/**\n * Whether the object contains the property passed as an own property.\n */\nexport const hasOwn =\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  Object.hasOwn || ((object: Dictionary, property: number | string | symbol) => hasOwnProperty.call(object, property));\n\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nexport function sameValueZeroEqual(a: any, b: any): boolean {\n  return a === b || (!a && !b && a !== a && b !== b);\n}\n","import type { Dictionary, PrimitiveWrapper, State, TypedArray } from './internalTypes.js';\nimport { getStrictProperties, hasOwn, sameValueZeroEqual } from './utils.js';\n\nconst PREACT_VNODE = '__v';\nconst PREACT_OWNER = '__o';\nconst REACT_OWNER = '_owner';\n\nconst { getOwnPropertyDescriptor, keys } = Object;\n\n/**\n * Whether the array buffers are equal in value.\n */\nexport function areArrayBuffersEqual(a: ArrayBuffer, b: ArrayBuffer): boolean {\n  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));\n}\n\n/**\n * Whether the arrays are equal in value.\n */\nexport function areArraysEqual(a: any[], b: any[], state: State<any>) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the dataviews are equal in value.\n */\nexport function areDataViewsEqual(a: DataView, b: DataView): boolean {\n  return (\n    a.byteLength === b.byteLength\n    && areTypedArraysEqual(\n      new Uint8Array(a.buffer, a.byteOffset, a.byteLength),\n      new Uint8Array(b.buffer, b.byteOffset, b.byteLength),\n    )\n  );\n}\n\n/**\n * Whether the dates passed are equal in value.\n */\nexport function areDatesEqual(a: Date, b: Date): boolean {\n  return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n\n/**\n * Whether the errors passed are equal in value.\n */\nexport function areErrorsEqual(a: Error, b: Error): boolean {\n  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;\n}\n\n/**\n * Whether the functions passed are equal in value.\n */\nexport function areFunctionsEqual(a: (...args: any[]) => any, b: (...args: any[]) => any): boolean {\n  return a === b;\n}\n\n/**\n * Whether the `Map`s are equal in value.\n */\nexport function areMapsEqual(a: Map<any, any>, b: Map<any, any>, state: State<any>): boolean {\n  const size = a.size;\n\n  if (size !== b.size) {\n    return false;\n  }\n\n  if (!size) {\n    return true;\n  }\n\n  const matchedIndices = new Array<true | undefined>(size);\n  const aIterable = a.entries();\n\n  let aResult: IteratorResult<[any, any]>;\n  let bResult: IteratorResult<[any, any]>;\n  let index = 0;\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.entries();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      if (matchedIndices[matchIndex]) {\n        matchIndex++;\n        continue;\n      }\n\n      const aEntry = aResult.value;\n      const bEntry = bResult.value;\n\n      if (\n        state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state)\n        && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)\n      ) {\n        hasMatch = matchedIndices[matchIndex] = true;\n        break;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\n/**\n * Whether the numbers are equal in value.\n */\nexport const areNumbersEqual = sameValueZeroEqual;\n\n/**\n * Whether the objects are equal in value.\n */\nexport function areObjectsEqual(a: Dictionary, b: Dictionary, state: State<any>): boolean {\n  const properties = keys(a);\n\n  let index = properties.length;\n\n  if (keys(b).length !== index) {\n    return false;\n  }\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    if (!isPropertyEqual(a, b, state, properties[index]!)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nexport function areObjectsEqualStrict(a: Dictionary, b: Dictionary, state: State<any>): boolean {\n  const properties = getStrictProperties(a);\n\n  let index = properties.length;\n\n  if (getStrictProperties(b).length !== index) {\n    return false;\n  }\n\n  let property: string | symbol;\n  let descriptorA: ReturnType<typeof getOwnPropertyDescriptor>;\n  let descriptorB: ReturnType<typeof getOwnPropertyDescriptor>;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index]!;\n\n    if (!isPropertyEqual(a, b, state, property)) {\n      return false;\n    }\n\n    descriptorA = getOwnPropertyDescriptor(a, property);\n    descriptorB = getOwnPropertyDescriptor(b, property);\n\n    if (\n      (descriptorA || descriptorB)\n      && (!descriptorA\n        || !descriptorB\n        || descriptorA.configurable !== descriptorB.configurable\n        || descriptorA.enumerable !== descriptorB.enumerable\n        || descriptorA.writable !== descriptorB.writable)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nexport function arePrimitiveWrappersEqual(a: PrimitiveWrapper, b: PrimitiveWrapper): boolean {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n\n/**\n * Whether the regexps passed are equal in value.\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp): boolean {\n  return a.source === b.source && a.flags === b.flags;\n}\n\n/**\n * Whether the `Set`s are equal in value.\n */\nexport function areSetsEqual(a: Set<any>, b: Set<any>, state: State<any>): boolean {\n  const size = a.size;\n\n  if (size !== b.size) {\n    return false;\n  }\n\n  if (!size) {\n    return true;\n  }\n\n  const matchedIndices = new Array<true | undefined>(size);\n  const aIterable = a.values();\n\n  let aResult: IteratorResult<any>;\n  let bResult: IteratorResult<any>;\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.values();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      if (\n        !matchedIndices[matchIndex]\n        && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)\n      ) {\n        hasMatch = matchedIndices[matchIndex] = true;\n        break;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the TypedArray instances are equal in value.\n */\nexport function areTypedArraysEqual(a: TypedArray, b: TypedArray) {\n  let index = a.byteLength;\n\n  if (b.byteLength !== index || a.byteOffset !== b.byteOffset) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the URL instances are equal in value.\n */\nexport function areUrlsEqual(a: URL, b: URL): boolean {\n  return (\n    a.hostname === b.hostname\n    && a.pathname === b.pathname\n    && a.protocol === b.protocol\n    && a.port === b.port\n    && a.hash === b.hash\n    && a.username === b.username\n    && a.password === b.password\n  );\n}\n\nfunction isPropertyEqual(a: Dictionary, b: Dictionary, state: State<any>, property: string | symbol) {\n  if (\n    (property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE)\n    && (a.$$typeof || b.$$typeof)\n  ) {\n    return true;\n  }\n\n  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);\n}\n","import {\n  areArrayBuffersEqual,\n  areArraysEqual as areArraysEqualDefault,\n  areDataViewsEqual,\n  areDatesEqual as areDatesEqualDefault,\n  areErrorsEqual as areErrorsEqualDefault,\n  areFunctionsEqual as areFunctionsEqualDefault,\n  areMapsEqual as areMapsEqualDefault,\n  areNumbersEqual as areNumbersEqualDefault,\n  areObjectsEqual as areObjectsEqualDefault,\n  areObjectsEqualStrict as areObjectsEqualStrictDefault,\n  arePrimitiveWrappersEqual as arePrimitiveWrappersEqualDefault,\n  areRegExpsEqual as areRegExpsEqualDefault,\n  areSetsEqual as areSetsEqualDefault,\n  areTypedArraysEqual as areTypedArraysEqualDefault,\n  areUrlsEqual as areUrlsEqualDefault,\n} from './equals.js';\nimport type {\n  ComparatorConfig,\n  CreateState,\n  CustomEqualCreatorOptions,\n  EqualityComparator,\n  InternalEqualityComparator,\n  State,\n} from './internalTypes.js';\nimport { combineComparators, createIsCircular, getShortTag } from './utils.js';\n\nconst ARRAY_BUFFER_TAG = '[object ArrayBuffer]';\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATA_VIEW_TAG = '[object DataView]';\nconst DATE_TAG = '[object Date]';\nconst ERROR_TAG = '[object Error]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\nconst TYPED_ARRAY_TAGS: Record<string, boolean> = {\n  '[object Int8Array]': true,\n  '[object Uint8Array]': true,\n  '[object Uint8ClampedArray]': true,\n  '[object Int16Array]': true,\n  '[object Uint16Array]': true,\n  '[object Int32Array]': true,\n  '[object Uint32Array]': true,\n  '[object Float16Array]': true,\n  '[object Float32Array]': true,\n  '[object Float64Array]': true,\n  '[object BigInt64Array]': true,\n  '[object BigUint64Array]': true,\n};\nconst URL_TAG = '[object URL]';\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toString = Object.prototype.toString;\n\ninterface CreateIsEqualOptions<Meta> {\n  circular: boolean;\n  comparator: EqualityComparator<Meta>;\n  createState: CreateState<Meta> | undefined;\n  equals: InternalEqualityComparator<Meta>;\n  strict: boolean;\n}\n\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nexport function createEqualityComparator<Meta>({\n  areArrayBuffersEqual,\n  areArraysEqual,\n  areDataViewsEqual,\n  areDatesEqual,\n  areErrorsEqual,\n  areFunctionsEqual,\n  areMapsEqual,\n  areNumbersEqual,\n  areObjectsEqual,\n  arePrimitiveWrappersEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  areTypedArraysEqual,\n  areUrlsEqual,\n  unknownTagComparators,\n}: ComparatorConfig<Meta>): EqualityComparator<Meta> {\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n  return function comparator(a: any, b: any, state: State<Meta>): boolean {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    }\n\n    // If either of the items are nullish and fail the strictly equal check\n    // above, then they must be unequal.\n    if (a == null || b == null) {\n      return false;\n    }\n\n    const type = typeof a;\n\n    if (type !== typeof b) {\n      return false;\n    }\n\n    if (type !== 'object') {\n      if (type === 'number') {\n        return areNumbersEqual(a, b, state);\n      }\n\n      if (type === 'function') {\n        return areFunctionsEqual(a, b, state);\n      }\n\n      // If a primitive value that is not strictly equal, it must be unequal.\n      return false;\n    }\n\n    const constructor = a.constructor;\n\n    // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n\n    // Constructors should match, otherwise there is potential for false positives\n    // between class and subclass or custom object and POJO.\n    if (constructor !== b.constructor) {\n      return false;\n    }\n\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid capturing the string tag.\n    if (constructor === Object) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n    // the string tag or doing an `instanceof` check.\n    if (Array.isArray(a)) {\n      return areArraysEqual(a, b, state);\n    }\n\n    // Try to fast-path equality checks for other complex object types in the\n    // same realm to avoid capturing the string tag. Strict equality is used\n    // instead of `instanceof` because it is more performant for the common\n    // use-case. If someone is subclassing a native class, it will be handled\n    // with the string tag comparison.\n\n    if (constructor === Date) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (constructor === RegExp) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (constructor === Map) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (constructor === Set) {\n      return areSetsEqual(a, b, state);\n    }\n\n    // Since this is a custom object, capture the string tag to determing its type.\n    // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n    const tag = toString.call(a);\n\n    if (tag === DATE_TAG) {\n      return areDatesEqual(a, b, state);\n    }\n\n    // For RegExp, the properties are not enumerable, and therefore will give false positives if\n    // tested like a standard object.\n    if (tag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (tag === MAP_TAG) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (tag === SET_TAG) {\n      return areSetsEqual(a, b, state);\n    }\n\n    if (tag === OBJECT_TAG) {\n      // The exception for value comparison is custom `Promise`-like class instances. These should\n      // be treated the same as standard `Promise` objects, which means strict equality, and if\n      // it reaches this point then that strict equality comparison has already failed.\n      return typeof a.then !== 'function' && typeof b.then !== 'function' && areObjectsEqual(a, b, state);\n    }\n\n    // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n    // enumerable, and therefore will give false positives if tested like a standard object.\n    if (tag === URL_TAG) {\n      return areUrlsEqual(a, b, state);\n    }\n\n    // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n    // enumerable, and therefore will give false positives if tested like a standard object.\n    if (tag === ERROR_TAG) {\n      return areErrorsEqual(a, b, state);\n    }\n\n    // If an arguments tag, it should be treated as a standard object.\n    if (tag === ARGUMENTS_TAG) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    if (TYPED_ARRAY_TAGS[tag]) {\n      return areTypedArraysEqual(a, b, state);\n    }\n\n    if (tag === ARRAY_BUFFER_TAG) {\n      return areArrayBuffersEqual(a, b, state);\n    }\n\n    if (tag === DATA_VIEW_TAG) {\n      return areDataViewsEqual(a, b, state);\n    }\n\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n      return arePrimitiveWrappersEqual(a, b, state);\n    }\n\n    if (unknownTagComparators) {\n      let unknownTagComparator = unknownTagComparators[tag];\n\n      if (!unknownTagComparator) {\n        const shortTag = getShortTag(a);\n\n        if (shortTag) {\n          unknownTagComparator = unknownTagComparators[shortTag];\n        }\n      }\n\n      // If the custom config has an unknown tag comparator that matches the captured tag or the\n      // @@toStringTag, it is the source of truth for whether the values are equal.\n      if (unknownTagComparator) {\n        return unknownTagComparator(a, b, state);\n      }\n    }\n\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n    return false;\n  };\n}\n\n/**\n * Create the configuration object used for building comparators.\n */\nexport function createEqualityComparatorConfig<Meta>({\n  circular,\n  createCustomConfig,\n  strict,\n}: CustomEqualCreatorOptions<Meta>): ComparatorConfig<Meta> {\n  let config = {\n    areArrayBuffersEqual,\n    areArraysEqual: strict ? areObjectsEqualStrictDefault : areArraysEqualDefault,\n    areDataViewsEqual,\n    areDatesEqual: areDatesEqualDefault,\n    areErrorsEqual: areErrorsEqualDefault,\n    areFunctionsEqual: areFunctionsEqualDefault,\n    areMapsEqual: strict ? combineComparators(areMapsEqualDefault, areObjectsEqualStrictDefault) : areMapsEqualDefault,\n    areNumbersEqual: areNumbersEqualDefault,\n    areObjectsEqual: strict ? areObjectsEqualStrictDefault : areObjectsEqualDefault,\n    arePrimitiveWrappersEqual: arePrimitiveWrappersEqualDefault,\n    areRegExpsEqual: areRegExpsEqualDefault,\n    areSetsEqual: strict ? combineComparators(areSetsEqualDefault, areObjectsEqualStrictDefault) : areSetsEqualDefault,\n    areTypedArraysEqual: strict\n      ? combineComparators(areTypedArraysEqualDefault, areObjectsEqualStrictDefault)\n      : areTypedArraysEqualDefault,\n    areUrlsEqual: areUrlsEqualDefault,\n    unknownTagComparators: undefined,\n  };\n\n  if (createCustomConfig) {\n    config = Object.assign({}, config, createCustomConfig(config));\n  }\n\n  if (circular) {\n    const areArraysEqual = createIsCircular(config.areArraysEqual);\n    const areMapsEqual = createIsCircular(config.areMapsEqual);\n    const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n    const areSetsEqual = createIsCircular(config.areSetsEqual);\n\n    config = Object.assign({}, config, {\n      areArraysEqual,\n      areMapsEqual,\n      areObjectsEqual,\n      areSetsEqual,\n    });\n  }\n\n  return config;\n}\n\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nexport function createInternalEqualityComparator<Meta>(\n  compare: EqualityComparator<Meta>,\n): InternalEqualityComparator<Meta> {\n  return function (\n    a: any,\n    b: any,\n    _indexOrKeyA: any,\n    _indexOrKeyB: any,\n    _parentA: any,\n    _parentB: any,\n    state: State<Meta>,\n  ) {\n    return compare(a, b, state);\n  };\n}\n\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nexport function createIsEqual<Meta>({ circular, comparator, createState, equals, strict }: CreateIsEqualOptions<Meta>) {\n  if (createState) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      const { cache = circular ? new WeakMap() : undefined, meta } = createState();\n\n      return comparator(a, b, {\n        cache,\n        equals,\n        meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  if (circular) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      return comparator(a, b, {\n        cache: new WeakMap(),\n        equals,\n        meta: undefined as Meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  const state = {\n    cache: undefined,\n    equals,\n    meta: undefined,\n    strict,\n  } as State<Meta>;\n\n  return function isEqual<A, B>(a: A, b: B): boolean {\n    return comparator(a, b, state);\n  };\n}\n","import {\n  createEqualityComparatorConfig,\n  createEqualityComparator,\n  createInternalEqualityComparator,\n  createIsEqual,\n} from './comparator.js';\nimport type { CustomEqualCreatorOptions } from './internalTypes.js';\nimport { sameValueZeroEqual } from './utils.js';\n\nexport { sameValueZeroEqual };\nexport type {\n  AnyEqualityComparator,\n  Cache,\n  CircularState,\n  ComparatorConfig,\n  CreateCustomComparatorConfig,\n  CreateState,\n  CustomEqualCreatorOptions,\n  DefaultState,\n  Dictionary,\n  EqualityComparator,\n  EqualityComparatorCreator,\n  InternalEqualityComparator,\n  PrimitiveWrapper,\n  State,\n  TypeEqualityComparator,\n  TypedArray,\n} from './internalTypes.js';\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nexport const deepEqual = createCustomEqual();\n\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nexport const strictDeepEqual = createCustomEqual({ strict: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nexport const circularDeepEqual = createCustomEqual({ circular: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularDeepEqual = createCustomEqual({\n  circular: true,\n  strict: true,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nexport const shallowEqual = createCustomEqual({\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nexport const strictShallowEqual = createCustomEqual({\n  strict: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nexport const circularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n  strict: true,\n});\n\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nexport function createCustomEqual<Meta = undefined>(options: CustomEqualCreatorOptions<Meta> = {}) {\n  const {\n    circular = false,\n    createInternalComparator: createCustomInternalComparator,\n    createState,\n    strict = false,\n  } = options;\n\n  const config = createEqualityComparatorConfig<Meta>(options);\n  const comparator = createEqualityComparator(config);\n  const equals = createCustomInternalComparator\n    ? createCustomInternalComparator(comparator)\n    : createInternalEqualityComparator(comparator);\n\n  return createIsEqual({ circular, comparator, createState, equals, strict });\n}\n","import type { Editor } from '@tiptap/core'\nimport type { ForwardedRef, HTMLProps, LegacyRef, MutableRefObject } from 'react'\nimport React, { forwardRef } from 'react'\nimport ReactDOM from 'react-dom'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js'\n\nimport type { ContentComponent, EditorWithContentComponent } from './Editor.js'\nimport type { ReactRenderer } from './ReactRenderer.js'\n\nconst mergeRefs = <T extends HTMLDivElement>(...refs: Array<MutableRefObject<T> | LegacyRef<T> | undefined>) => {\n  return (node: T) => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node)\n      } else if (ref) {\n        ;(ref as MutableRefObject<T | null>).current = node\n      }\n    })\n  }\n}\n\n/**\n * This component renders all of the editor's node views.\n */\nconst Portals: React.FC<{ contentComponent: ContentComponent }> = ({ contentComponent }) => {\n  // For performance reasons, we render the node view portals on state changes only\n  const renderers = useSyncExternalStore(\n    contentComponent.subscribe,\n    contentComponent.getSnapshot,\n    contentComponent.getServerSnapshot,\n  )\n\n  // This allows us to directly render the portals without any additional wrapper\n  return <>{Object.values(renderers)}</>\n}\n\nexport interface EditorContentProps extends HTMLProps<HTMLDivElement> {\n  editor: Editor | null\n  innerRef?: ForwardedRef<HTMLDivElement | null>\n}\n\nfunction getInstance(): ContentComponent {\n  const subscribers = new Set<() => void>()\n  let renderers: Record<string, React.ReactPortal> = {}\n\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback: () => void) {\n      subscribers.add(callback)\n      return () => {\n        subscribers.delete(callback)\n      }\n    },\n    getSnapshot() {\n      return renderers\n    },\n    getServerSnapshot() {\n      return renderers\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id: string, renderer: ReactRenderer) {\n      renderers = {\n        ...renderers,\n        [id]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id),\n      }\n\n      subscribers.forEach(subscriber => subscriber())\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id: string) {\n      const nextRenderers = { ...renderers }\n\n      delete nextRenderers[id]\n      renderers = nextRenderers\n      subscribers.forEach(subscriber => subscriber())\n    },\n  }\n}\n\nexport class PureEditorContent extends React.Component<\n  EditorContentProps,\n  { hasContentComponentInitialized: boolean }\n> {\n  editorContentRef: React.RefObject<any>\n\n  initialized: boolean\n\n  unsubscribeToContentComponent?: () => void\n\n  constructor(props: EditorContentProps) {\n    super(props)\n    this.editorContentRef = React.createRef()\n    this.initialized = false\n\n    this.state = {\n      hasContentComponentInitialized: Boolean((props.editor as EditorWithContentComponent | null)?.contentComponent),\n    }\n  }\n\n  componentDidMount() {\n    this.init()\n  }\n\n  componentDidUpdate() {\n    this.init()\n  }\n\n  init() {\n    const editor = this.props.editor as EditorWithContentComponent | null\n\n    if (editor && !editor.isDestroyed && editor.view.dom?.parentNode) {\n      if (editor.contentComponent) {\n        return\n      }\n\n      const element = this.editorContentRef.current\n\n      element.append(...editor.view.dom.parentNode.childNodes)\n\n      editor.setOptions({\n        element,\n      })\n\n      editor.contentComponent = getInstance()\n\n      // Has the content component been initialized?\n      if (!this.state.hasContentComponentInitialized) {\n        // Subscribe to the content component\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState(prevState => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true,\n              }\n            }\n            return prevState\n          })\n\n          // Unsubscribe to previous content component\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent()\n          }\n        })\n      }\n\n      editor.createNodeViews()\n\n      this.initialized = true\n    }\n  }\n\n  componentWillUnmount() {\n    const editor = this.props.editor as EditorWithContentComponent | null\n\n    if (!editor) {\n      return\n    }\n\n    this.initialized = false\n\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {},\n      })\n    }\n\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent()\n    }\n\n    editor.contentComponent = null\n\n    // try to reset the editor element\n    // may fail if this editor's view.dom was never initialized/mounted yet\n    try {\n      if (!editor.view.dom?.parentNode) {\n        return\n      }\n\n      // TODO using the new editor.mount method might allow us to remove this\n      const newElement = document.createElement('div')\n\n      newElement.append(...editor.view.dom.parentNode.childNodes)\n\n      editor.setOptions({\n        element: newElement,\n      })\n    } catch {\n      // do nothing, nothing to reset\n    }\n  }\n\n  render() {\n    const { editor, innerRef, ...rest } = this.props\n\n    return (\n      <>\n        <div ref={mergeRefs(innerRef, this.editorContentRef)} {...rest} />\n        {/* @ts-ignore */}\n        {editor?.contentComponent && <Portals contentComponent={editor.contentComponent} />}\n      </>\n    )\n  }\n}\n\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = forwardRef<HTMLDivElement, EditorContentProps>(\n  (props: Omit<EditorContentProps, 'innerRef'>, ref) => {\n    const key = React.useMemo(() => {\n      return Math.floor(Math.random() * 0xffffffff).toString()\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [props.editor])\n\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return React.createElement(PureEditorContent, {\n      key,\n      innerRef: ref,\n      ...props,\n    })\n  },\n)\n\nexport const EditorContent = React.memo(EditorContentWithKey)\n","import type { Editor } from '@tiptap/core'\nimport { deepEqual } from 'fast-equals'\nimport { useDebugValue, useEffect, useLayoutEffect, useState } from 'react'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n\nexport type EditorStateSnapshot<TEditor extends Editor | null = Editor | null> = {\n  editor: TEditor\n  transactionNumber: number\n}\n\nexport type UseEditorStateOptions<TSelectorResult, TEditor extends Editor | null = Editor | null> = {\n  /**\n   * The editor instance.\n   */\n  editor: TEditor\n  /**\n   * A selector function to determine the value to compare for re-rendering.\n   */\n  selector: (context: EditorStateSnapshot<TEditor>) => TSelectorResult\n  /**\n   * A custom equality function to determine if the editor should re-render.\n   * @default `deepEqual` from `fast-deep-equal`\n   */\n  equalityFn?: (a: TSelectorResult, b: TSelectorResult | null) => boolean\n}\n\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */\nclass EditorStateManager<TEditor extends Editor | null = Editor | null> {\n  private transactionNumber = 0\n\n  private lastTransactionNumber = 0\n\n  private lastSnapshot: EditorStateSnapshot<TEditor>\n\n  private editor: TEditor\n\n  private subscribers = new Set<() => void>()\n\n  constructor(initialEditor: TEditor) {\n    this.editor = initialEditor\n    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 }\n\n    this.getSnapshot = this.getSnapshot.bind(this)\n    this.getServerSnapshot = this.getServerSnapshot.bind(this)\n    this.watch = this.watch.bind(this)\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot(): EditorStateSnapshot<TEditor> {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot\n    }\n    this.lastTransactionNumber = this.transactionNumber\n    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }\n    return this.lastSnapshot\n  }\n\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot(): EditorStateSnapshot<null> {\n    return { editor: null, transactionNumber: 0 }\n  }\n\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback: () => void): () => void {\n    this.subscribers.add(callback)\n    return () => {\n      this.subscribers.delete(callback)\n    }\n  }\n\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor: Editor | null): undefined | (() => void) {\n    this.editor = nextEditor as TEditor\n\n    if (this.editor) {\n      /**\n       * This will force a re-render when the editor state changes.\n       * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n       * This could be more efficient, but it's a good trade-off for now.\n       */\n      const fn = () => {\n        this.transactionNumber += 1\n        this.subscribers.forEach(callback => callback())\n      }\n\n      const currentEditor = this.editor\n\n      currentEditor.on('transaction', fn)\n      return () => {\n        currentEditor.off('transaction', fn)\n      }\n    }\n\n    return undefined\n  }\n}\n\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor>,\n): TSelectorResult\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor | null>,\n): TSelectorResult | null\n\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor> | UseEditorStateOptions<TSelectorResult, Editor | null>,\n): TSelectorResult | null {\n  const [editorStateManager] = useState(() => new EditorStateManager(options.editor))\n\n  // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n  const selectedState = useSyncExternalStoreWithSelector(\n    editorStateManager.subscribe,\n    editorStateManager.getSnapshot,\n    editorStateManager.getServerSnapshot,\n    options.selector as UseEditorStateOptions<TSelectorResult, Editor | null>['selector'],\n    options.equalityFn ?? deepEqual,\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor)\n  }, [options.editor, editorStateManager])\n\n  useDebugValue(selectedState)\n\n  return selectedState\n}\n","import { type EditorOptions, Editor } from '@tiptap/core'\nimport type { DependencyList, MutableRefObject } from 'react'\nimport { useDebugValue, useEffect, useRef, useState } from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js'\n\nimport { useEditorState } from './useEditorState.js'\n\n// @ts-ignore\nconst isDev = process.env.NODE_ENV !== 'production'\nconst isSSR = typeof window === 'undefined'\nconst isNext = isSSR || Boolean(typeof window !== 'undefined' && (window as any).next)\n\n/**\n * The options for the `useEditor` hook.\n */\nexport type UseEditorOptions = Partial<EditorOptions> & {\n  /**\n   * Whether to render the editor on the first render.\n   * If client-side rendering, set this to `true`.\n   * If server-side rendering, set this to `false`.\n   * @default true\n   */\n  immediatelyRender?: boolean\n  /**\n   * Whether to re-render the editor on each transaction.\n   * This is legacy behavior that will be removed in future versions.\n   * @default false\n   */\n  shouldRerenderOnTransaction?: boolean\n}\n\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */\nclass EditorInstanceManager {\n  /**\n   * The current editor instance.\n   */\n  private editor: Editor | null = null\n\n  /**\n   * The most recent options to apply to the editor.\n   */\n  private options: MutableRefObject<UseEditorOptions>\n\n  /**\n   * The subscriptions to notify when the editor instance\n   * has been created or destroyed.\n   */\n  private subscriptions = new Set<() => void>()\n\n  /**\n   * A timeout to destroy the editor if it was not mounted within a time frame.\n   */\n  private scheduledDestructionTimeout: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * Whether the editor has been mounted.\n   */\n  private isComponentMounted = false\n\n  /**\n   * The most recent dependencies array.\n   */\n  private previousDeps: DependencyList | null = null\n\n  /**\n   * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n   */\n  public instanceId = ''\n\n  constructor(options: MutableRefObject<UseEditorOptions>) {\n    this.options = options\n    this.subscriptions = new Set<() => void>()\n    this.setEditor(this.getInitialEditor())\n    this.scheduleDestroy()\n\n    this.getEditor = this.getEditor.bind(this)\n    this.getServerSnapshot = this.getServerSnapshot.bind(this)\n    this.subscribe = this.subscribe.bind(this)\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this)\n    this.scheduleDestroy = this.scheduleDestroy.bind(this)\n    this.onRender = this.onRender.bind(this)\n    this.createEditor = this.createEditor.bind(this)\n  }\n\n  private setEditor(editor: Editor | null) {\n    this.editor = editor\n    this.instanceId = Math.random().toString(36).slice(2, 9)\n\n    // Notify all subscribers that the editor instance has been created\n    this.subscriptions.forEach(cb => cb())\n  }\n\n  private getInitialEditor() {\n    if (this.options.current.immediatelyRender === undefined) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          /**\n           * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n           * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n           */\n          throw new Error(\n            'Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.',\n          )\n        }\n\n        // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n        return null\n      }\n\n      // Default to immediately rendering when client-side rendering\n      return this.createEditor()\n    }\n\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n      throw new Error(\n        'Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.',\n      )\n    }\n\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor()\n    }\n\n    return null\n  }\n\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  private createEditor(): Editor {\n    const optionsToApply: Partial<EditorOptions> = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => this.options.current.onBeforeCreate?.(...args),\n      onBlur: (...args) => this.options.current.onBlur?.(...args),\n      onCreate: (...args) => this.options.current.onCreate?.(...args),\n      onDestroy: (...args) => this.options.current.onDestroy?.(...args),\n      onFocus: (...args) => this.options.current.onFocus?.(...args),\n      onSelectionUpdate: (...args) => this.options.current.onSelectionUpdate?.(...args),\n      onTransaction: (...args) => this.options.current.onTransaction?.(...args),\n      onUpdate: (...args) => this.options.current.onUpdate?.(...args),\n      onContentError: (...args) => this.options.current.onContentError?.(...args),\n      onDrop: (...args) => this.options.current.onDrop?.(...args),\n      onPaste: (...args) => this.options.current.onPaste?.(...args),\n      onDelete: (...args) => this.options.current.onDelete?.(...args),\n    }\n    const editor = new Editor(optionsToApply)\n\n    // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n\n    return editor\n  }\n\n  /**\n   * Get the current editor instance.\n   */\n  getEditor(): Editor | null {\n    return this.editor\n  }\n\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot(): null {\n    return null\n  }\n\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange: () => void) {\n    this.subscriptions.add(onStoreChange)\n\n    return () => {\n      this.subscriptions.delete(onStoreChange)\n    }\n  }\n\n  static compareOptions(a: UseEditorOptions, b: UseEditorOptions) {\n    return (Object.keys(a) as (keyof UseEditorOptions)[]).every(key => {\n      if (\n        [\n          'onCreate',\n          'onBeforeCreate',\n          'onDestroy',\n          'onUpdate',\n          'onTransaction',\n          'onFocus',\n          'onBlur',\n          'onSelectionUpdate',\n          'onContentError',\n          'onDrop',\n          'onPaste',\n        ].includes(key)\n      ) {\n        // we don't want to compare callbacks, they are always different and only registered once\n        return true\n      }\n\n      // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n      if (key === 'extensions' && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false\n        }\n        return a.extensions.every((extension, index) => {\n          if (extension !== b.extensions?.[index]) {\n            return false\n          }\n          return true\n        })\n      }\n      if (a[key] !== b[key]) {\n        // if any of the options have changed, we should update the editor options\n        return false\n      }\n      return true\n    })\n  }\n\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps: DependencyList) {\n    // The returned callback will run on each render\n    return () => {\n      this.isComponentMounted = true\n      // Cleanup any scheduled destructions, since we are currently rendering\n      clearTimeout(this.scheduledDestructionTimeout)\n\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n        if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          // But, the options are different, so we need to update the editor options\n          // Still, this is faster than re-creating the editor\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable,\n          })\n        }\n      } else {\n        // When the editor:\n        // - does not yet exist\n        // - is destroyed\n        // - the deps array changes\n        // We need to destroy the editor instance and re-initialize it\n        this.refreshEditorInstance(deps)\n      }\n\n      return () => {\n        this.isComponentMounted = false\n        this.scheduleDestroy()\n      }\n    }\n  }\n\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  private refreshEditorInstance(deps: DependencyList) {\n    if (this.editor && !this.editor.isDestroyed) {\n      // Editor instance already exists\n      if (this.previousDeps === null) {\n        // If lastDeps has not yet been initialized, reuse the current editor instance\n        this.previousDeps = deps\n        return\n      }\n      const depsAreEqual =\n        this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index])\n\n      if (depsAreEqual) {\n        // deps exist and are equal, no need to recreate\n        return\n      }\n    }\n\n    if (this.editor && !this.editor.isDestroyed) {\n      // Destroy the editor instance if it exists\n      this.editor.destroy()\n    }\n\n    this.setEditor(this.createEditor())\n\n    // Update the lastDeps to the current deps\n    this.previousDeps = deps\n  }\n\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  private scheduleDestroy() {\n    const currentInstanceId = this.instanceId\n    const currentEditor = this.editor\n\n    // Wait two ticks to see if the component is still mounted\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n        if (currentEditor) {\n          // just re-apply options as they might have changed\n          currentEditor.setOptions(this.options.current)\n        }\n        return\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy()\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null)\n        }\n      }\n      // This allows the effect to run again between ticks\n      // which may save us from having to re-create the editor\n    }, 1)\n  }\n}\n\n/**\n * This hook allows you to create an editor instance.\n * @param options The editor options\n * @param deps The dependencies to watch for changes\n * @returns The editor instance\n * @example const editor = useEditor({ extensions: [...] })\n */\nexport function useEditor(\n  options: UseEditorOptions & { immediatelyRender: false },\n  deps?: DependencyList,\n): Editor | null\n\n/**\n * This hook allows you to create an editor instance.\n * @param options The editor options\n * @param deps The dependencies to watch for changes\n * @returns The editor instance\n * @example const editor = useEditor({ extensions: [...] })\n */\nexport function useEditor(options: UseEditorOptions, deps?: DependencyList): Editor\n\nexport function useEditor(options: UseEditorOptions = {}, deps: DependencyList = []): Editor | null {\n  const mostRecentOptions = useRef(options)\n\n  mostRecentOptions.current = options\n\n  const [instanceManager] = useState(() => new EditorInstanceManager(mostRecentOptions))\n\n  const editor = useSyncExternalStore(\n    instanceManager.subscribe,\n    instanceManager.getEditor,\n    instanceManager.getServerSnapshot,\n  )\n\n  useDebugValue(editor)\n\n  // This effect will handle creating/updating the editor instance\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(instanceManager.onRender(deps))\n\n  // The default behavior is to re-render on each transaction\n  // This is legacy behavior that will be removed in future versions\n  useEditorState({\n    editor,\n    selector: ({ transactionNumber }) => {\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === undefined) {\n        // This will prevent the editor from re-rendering on each transaction\n        return null\n      }\n\n      // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0\n      }\n      return transactionNumber + 1\n    },\n  })\n\n  return editor\n}\n","import type { Editor } from '@tiptap/core'\nimport type { HTMLAttributes, ReactNode } from 'react'\nimport React, { createContext, useContext, useMemo } from 'react'\n\nimport { EditorContent } from './EditorContent.js'\nimport type { UseEditorOptions } from './useEditor.js'\nimport { useEditor } from './useEditor.js'\n\nexport type EditorContextValue = {\n  editor: Editor | null\n}\n\nexport const EditorContext = createContext<EditorContextValue>({\n  editor: null,\n})\n\nexport const EditorConsumer = EditorContext.Consumer\n\n/**\n * A hook to get the current editor instance.\n */\nexport const useCurrentEditor = () => useContext(EditorContext)\n\nexport type EditorProviderProps = {\n  children?: ReactNode\n  slotBefore?: ReactNode\n  slotAfter?: ReactNode\n  editorContainerProps?: HTMLAttributes<HTMLDivElement>\n} & UseEditorOptions\n\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */\nexport function EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}: EditorProviderProps) {\n  const editor = useEditor(editorOptions)\n  const contextValue = useMemo(() => ({ editor }), [editor])\n\n  if (!editor) {\n    return null\n  }\n\n  return (\n    <EditorContext.Provider value={contextValue}>\n      {slotBefore}\n      <EditorConsumer>\n        {({ editor: currentEditor }) => <EditorContent editor={currentEditor} {...editorContainerProps} />}\n      </EditorConsumer>\n      {children}\n      {slotAfter}\n    </EditorContext.Provider>\n  )\n}\n","import type { ReactNode } from 'react'\nimport { createContext, createElement, useContext } from 'react'\n\nexport interface ReactNodeViewContextProps {\n  onDragStart?: (event: DragEvent) => void\n  nodeViewContentRef?: (element: HTMLElement | null) => void\n  /**\n   * This allows you to add children into the NodeViewContent component.\n   * This is useful when statically rendering the content of a node view.\n   */\n  nodeViewContentChildren?: ReactNode\n}\n\nexport const ReactNodeViewContext = createContext<ReactNodeViewContextProps>({\n  onDragStart: () => {\n    // no-op\n  },\n  nodeViewContentChildren: undefined,\n  nodeViewContentRef: () => {\n    // no-op\n  },\n})\n\nexport const ReactNodeViewContentProvider = ({ children, content }: { children: ReactNode; content: ReactNode }) => {\n  return createElement(ReactNodeViewContext.Provider, { value: { nodeViewContentChildren: content } }, children)\n}\n\nexport const useReactNodeView = () => useContext(ReactNodeViewContext)\n","import React from 'react'\n\nimport { useReactNodeView } from './useReactNodeView.js'\n\nexport interface NodeViewWrapperProps {\n  [key: string]: any\n  as?: React.ElementType\n}\n\nexport const NodeViewWrapper: React.FC<NodeViewWrapperProps> = React.forwardRef((props, ref) => {\n  const { onDragStart } = useReactNodeView()\n  const Tag = props.as || 'div'\n\n  return (\n    // @ts-ignore\n    <Tag\n      {...props}\n      ref={ref}\n      data-node-view-wrapper=\"\"\n      onDragStart={onDragStart}\n      style={{\n        whiteSpace: 'normal',\n        ...props.style,\n      }}\n    />\n  )\n})\n","import type { Editor } from '@tiptap/core'\nimport type {\n  ComponentClass,\n  ForwardRefExoticComponent,\n  FunctionComponent,\n  PropsWithoutRef,\n  ReactNode,\n  RefAttributes,\n} from 'react'\nimport { version as reactVersion } from 'react'\nimport { flushSync } from 'react-dom'\n\nimport type { EditorWithContentComponent } from './Editor.js'\n\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */\nfunction isClassComponent(Component: any) {\n  return !!(typeof Component === 'function' && Component.prototype && Component.prototype.isReactComponent)\n}\n\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */\nfunction isForwardRefComponent(Component: any) {\n  return !!(\n    typeof Component === 'object' &&\n    Component.$$typeof &&\n    (Component.$$typeof.toString() === 'Symbol(react.forward_ref)' ||\n      Component.$$typeof.description === 'react.forward_ref')\n  )\n}\n\n/**\n * Check if a component is a memoized component.\n * @param Component\n * @returns {boolean}\n */\nfunction isMemoComponent(Component: any) {\n  return !!(\n    typeof Component === 'object' &&\n    Component.$$typeof &&\n    (Component.$$typeof.toString() === 'Symbol(react.memo)' || Component.$$typeof.description === 'react.memo')\n  )\n}\n\n/**\n * Check if a component can safely receive a ref prop.\n * This includes class components, forwardRef components, and memoized components\n * that wrap forwardRef or class components.\n * @param Component\n * @returns {boolean}\n */\nfunction canReceiveRef(Component: any) {\n  // Check if it's a class component\n  if (isClassComponent(Component)) {\n    return true\n  }\n\n  // Check if it's a forwardRef component\n  if (isForwardRefComponent(Component)) {\n    return true\n  }\n\n  // Check if it's a memoized component\n  if (isMemoComponent(Component)) {\n    // For memoized components, check the wrapped component\n    const wrappedComponent = Component.type\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent)\n    }\n  }\n\n  return false\n}\n\n/**\n * Check if we're running React 19+ by detecting if function components support ref props\n * @returns {boolean}\n */\nfunction isReact19Plus(): boolean {\n  // React 19 is detected by checking React version if available\n  // In practice, we'll use a more conservative approach and assume React 18 behavior\n  // unless we can definitively detect React 19\n  try {\n    // @ts-ignore\n    if (reactVersion) {\n      const majorVersion = parseInt(reactVersion.split('.')[0], 10)\n      return majorVersion >= 19\n    }\n  } catch {\n    // Fallback to React 18 behavior if we can't determine version\n  }\n  return false\n}\n\nexport interface ReactRendererOptions {\n  /**\n   * The editor instance.\n   * @type {Editor}\n   */\n  editor: Editor\n\n  /**\n   * The props for the component.\n   * @type {Record<string, any>}\n   * @default {}\n   */\n  props?: Record<string, any>\n\n  /**\n   * The tag name of the element.\n   * @type {string}\n   * @default 'div'\n   */\n  as?: string\n\n  /**\n   * The class name of the element.\n   * @type {string}\n   * @default ''\n   * @example 'foo bar'\n   */\n  className?: string\n}\n\ntype ComponentType<R, P> =\n  | ComponentClass<P>\n  | FunctionComponent<P>\n  | ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<R>>\n\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n */\nexport class ReactRenderer<R = unknown, P extends Record<string, any> = object> {\n  id: string\n\n  editor: Editor\n\n  component: any\n\n  element: HTMLElement\n\n  props: P\n\n  reactElement: ReactNode\n\n  ref: R | null = null\n\n  /**\n   * Flag to track if the renderer has been destroyed, preventing queued or asynchronous renders from executing after teardown.\n   */\n  destroyed = false\n\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(\n    component: ComponentType<R, P>,\n    { editor, props = {}, as = 'div', className = '' }: ReactRendererOptions,\n  ) {\n    this.id = Math.floor(Math.random() * 0xffffffff).toString()\n    this.component = component\n    this.editor = editor as EditorWithContentComponent\n    this.props = props as P\n    this.element = document.createElement(as)\n    this.element.classList.add('react-renderer')\n\n    if (className) {\n      this.element.classList.add(...className.split(' '))\n    }\n\n    // If the editor is already initialized, we will need to\n    // synchronously render the component to ensure it renders\n    // together with Prosemirror's rendering.\n    if (this.editor.isInitialized) {\n      flushSync(() => {\n        this.render()\n      })\n    } else {\n      queueMicrotask(() => {\n        if (this.destroyed) {\n          return\n        }\n        this.render()\n      })\n    }\n  }\n\n  /**\n   * Render the React component.\n   */\n  render(): void {\n    if (this.destroyed) {\n      return\n    }\n\n    const Component = this.component\n    const props = this.props\n    const editor = this.editor as EditorWithContentComponent\n\n    // Handle ref forwarding with React 18/19 compatibility\n    const isReact19 = isReact19Plus()\n    const componentCanReceiveRef = canReceiveRef(Component)\n\n    const elementProps = { ...props }\n\n    // Always remove ref if the component cannot receive it (unless React 19+)\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref\n    }\n\n    // Only assign our own ref if allowed\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      // @ts-ignore - Setting ref prop for compatible components\n      elementProps.ref = (ref: R) => {\n        this.ref = ref\n      }\n    }\n\n    this.reactElement = <Component {...elementProps} />\n\n    editor?.contentComponent?.setRenderer(this.id, this)\n  }\n\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props: Record<string, any> = {}): void {\n    if (this.destroyed) {\n      return\n    }\n\n    this.props = {\n      ...this.props,\n      ...props,\n    }\n\n    this.render()\n  }\n\n  /**\n   * Destroy the React component.\n   */\n  destroy(): void {\n    this.destroyed = true\n    const editor = this.editor as EditorWithContentComponent\n\n    editor?.contentComponent?.removeRenderer(this.id)\n    // If the consumer appended the element to the document (for example\n    // many demos append the renderer element to document.body), make sure\n    // we remove it here to avoid leaking DOM nodes / React roots.\n    try {\n      if (this.element && this.element.parentNode) {\n        this.element.parentNode.removeChild(this.element)\n      }\n    } catch {\n      // ignore DOM removal errors\n    }\n  }\n\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes: Record<string, string>): void {\n    Object.keys(attributes).forEach(key => {\n      this.element.setAttribute(key, attributes[key])\n    })\n  }\n}\n","/* eslint-disable @typescript-eslint/no-shadow */\nimport type { MarkViewProps, MarkViewRenderer, MarkViewRendererOptions } from '@tiptap/core'\nimport { MarkView } from '@tiptap/core'\nimport React from 'react'\n\n// import { flushSync } from 'react-dom'\nimport { ReactRenderer } from './ReactRenderer.js'\n\nexport interface MarkViewContextProps {\n  markViewContentRef: (element: HTMLElement | null) => void\n}\nexport const ReactMarkViewContext = React.createContext<MarkViewContextProps>({\n  markViewContentRef: () => {\n    // do nothing\n  },\n})\n\nexport type MarkViewContentProps<T extends keyof React.JSX.IntrinsicElements = 'span'> = {\n  as?: T\n} & Omit<React.ComponentProps<T>, 'as'>\n\nexport const MarkViewContent = <T extends keyof React.JSX.IntrinsicElements = 'span'>(\n  props: MarkViewContentProps<T>,\n) => {\n  const { as: Tag = 'span', ...rest } = props\n  const { markViewContentRef } = React.useContext(ReactMarkViewContext)\n\n  return (\n    // @ts-ignore\n    <Tag {...rest} ref={markViewContentRef} data-mark-view-content=\"\" />\n  )\n}\n\nexport interface ReactMarkViewRendererOptions extends MarkViewRendererOptions {\n  /**\n   * The tag name of the element wrapping the React component.\n   */\n  as?: string\n  className?: string\n  attrs?: { [key: string]: string }\n}\n\nexport class ReactMarkView extends MarkView<React.ComponentType<MarkViewProps>, ReactMarkViewRendererOptions> {\n  renderer: ReactRenderer\n  contentDOMElement: HTMLElement\n\n  constructor(\n    component: React.ComponentType<MarkViewProps>,\n    props: MarkViewProps,\n    options?: Partial<ReactMarkViewRendererOptions>,\n  ) {\n    super(component, props, options)\n\n    const { as = 'span', attrs, className = '' } = options || {}\n    const componentProps = { ...props, updateAttributes: this.updateAttributes.bind(this) } satisfies MarkViewProps\n\n    this.contentDOMElement = document.createElement('span')\n\n    const markViewContentRef: MarkViewContextProps['markViewContentRef'] = el => {\n      if (el && !el.contains(this.contentDOMElement)) {\n        el.appendChild(this.contentDOMElement)\n      }\n    }\n    const context: MarkViewContextProps = {\n      markViewContentRef,\n    }\n\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactMarkViewProvider: React.FunctionComponent<MarkViewProps> = React.memo(componentProps => {\n      return (\n        <ReactMarkViewContext.Provider value={context}>\n          {React.createElement(component, componentProps)}\n        </ReactMarkViewContext.Provider>\n      )\n    })\n\n    ReactMarkViewProvider.displayName = 'ReactMarkView'\n\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim(),\n    })\n\n    if (attrs) {\n      this.renderer.updateAttributes(attrs)\n    }\n  }\n\n  get dom() {\n    return this.renderer.element\n  }\n\n  get contentDOM() {\n    return this.contentDOMElement\n  }\n}\n\nexport function ReactMarkViewRenderer(\n  component: React.ComponentType<MarkViewProps>,\n  options: Partial<ReactMarkViewRendererOptions> = {},\n): MarkViewRenderer {\n  return props => new ReactMarkView(component, props, options)\n}\n","import type {\n  DecorationWithType,\n  Editor,\n  NodeViewRenderer,\n  NodeViewRendererOptions,\n  NodeViewRendererProps,\n} from '@tiptap/core'\nimport { getRenderedAttributes, NodeView } from '@tiptap/core'\nimport type { Node, Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport type { Decoration, DecorationSource, NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\nimport type { ComponentType, NamedExoticComponent } from 'react'\nimport { createElement, createRef, memo } from 'react'\n\nimport type { EditorWithContentComponent } from './Editor.js'\nimport { ReactRenderer } from './ReactRenderer.js'\nimport type { ReactNodeViewProps } from './types.js'\nimport type { ReactNodeViewContextProps } from './useReactNodeView.js'\nimport { ReactNodeViewContext } from './useReactNodeView.js'\n\nexport interface ReactNodeViewRendererOptions extends NodeViewRendererOptions {\n  /**\n   * This function is called when the node view is updated.\n   * It allows you to compare the old node with the new node and decide if the component should update.\n   */\n  update:\n    | ((props: {\n        oldNode: ProseMirrorNode\n        oldDecorations: readonly Decoration[]\n        oldInnerDecorations: DecorationSource\n        newNode: ProseMirrorNode\n        newDecorations: readonly Decoration[]\n        innerDecorations: DecorationSource\n        updateProps: () => void\n      }) => boolean)\n    | null\n  /**\n   * The tag name of the element wrapping the React component.\n   */\n  as?: string\n  /**\n   * The class name of the element wrapping the React component.\n   */\n  className?: string\n  /**\n   * Attributes that should be applied to the element wrapping the React component.\n   * If this is a function, it will be called each time the node view is updated.\n   * If this is an object, it will be applied once when the node view is mounted.\n   */\n  attrs?:\n    | Record<string, string>\n    | ((props: { node: ProseMirrorNode; HTMLAttributes: Record<string, any> }) => Record<string, string>)\n}\n\nexport class ReactNodeView<\n  T = HTMLElement,\n  Component extends ComponentType<ReactNodeViewProps<T>> = ComponentType<ReactNodeViewProps<T>>,\n  NodeEditor extends Editor = Editor,\n  Options extends ReactNodeViewRendererOptions = ReactNodeViewRendererOptions,\n> extends NodeView<Component, NodeEditor, Options> {\n  /**\n   * The renderer instance.\n   */\n  renderer!: ReactRenderer<unknown, ReactNodeViewProps<T>>\n\n  /**\n   * The element that holds the rich-text content of the node.\n   */\n  contentDOMElement!: HTMLElement | null\n\n  /**\n   * The requestAnimationFrame ID used for selection updates.\n   */\n  selectionRafId: number | null = null\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    super(component, props, options)\n\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag)\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div')\n      }\n\n      this.contentDOMElement.dataset.nodeViewContentReact = ''\n      this.contentDOMElement.dataset.nodeViewWrapper = ''\n\n      // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n      // With this fix it seems to work fine\n      // See: https://github.com/ueberdosis/tiptap/issues/1197\n      this.contentDOMElement.style.whiteSpace = 'inherit'\n\n      const contentTarget = this.dom.querySelector('[data-node-view-content]')\n\n      if (!contentTarget) {\n        return\n      }\n\n      contentTarget.appendChild(this.contentDOMElement)\n    }\n  }\n\n  private cachedExtensionWithSyncedStorage: NodeViewRendererProps['extension'] | null = null\n\n  /**\n   * Returns a proxy of the extension that redirects storage access to the editor's mutable storage.\n   * This preserves the original prototype chain (instanceof checks, methods like configure/extend work).\n   * Cached to avoid proxy creation on every update.\n   */\n  get extensionWithSyncedStorage(): NodeViewRendererProps['extension'] {\n    if (!this.cachedExtensionWithSyncedStorage) {\n      const editor = this.editor\n      const extension = this.extension\n\n      this.cachedExtensionWithSyncedStorage = new Proxy(extension, {\n        get(target, prop, receiver) {\n          if (prop === 'storage') {\n            return editor.storage[extension.name as keyof typeof editor.storage] ?? {}\n          }\n          return Reflect.get(target, prop, receiver)\n        },\n      })\n    }\n\n    return this.cachedExtensionWithSyncedStorage\n  }\n\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations as DecorationWithType[],\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extensionWithSyncedStorage,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: createRef<T>(),\n    } satisfies ReactNodeViewProps<T>\n\n    if (!(this.component as any).displayName) {\n      const capitalizeFirstChar = (string: string): string => {\n        return string.charAt(0).toUpperCase() + string.substring(1)\n      }\n\n      this.component.displayName = capitalizeFirstChar(this.extension.name)\n    }\n\n    const onDragStart = this.onDragStart.bind(this)\n    const nodeViewContentRef: ReactNodeViewContextProps['nodeViewContentRef'] = element => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        // remove the nodeViewWrapper attribute from the element\n        if (element.hasAttribute('data-node-view-wrapper')) {\n          element.removeAttribute('data-node-view-wrapper')\n        }\n        element.appendChild(this.contentDOMElement)\n      }\n    }\n    const context = { onDragStart, nodeViewContentRef }\n    const Component = this.component\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactNodeViewProvider: NamedExoticComponent<ReactNodeViewProps<T>> = memo(componentProps => {\n      return (\n        <ReactNodeViewContext.Provider value={context}>\n          {createElement(Component, componentProps)}\n        </ReactNodeViewContext.Provider>\n      )\n    })\n\n    ReactNodeViewProvider.displayName = 'ReactNodeView'\n\n    let as = this.node.isInline ? 'span' : 'div'\n\n    if (this.options.as) {\n      as = this.options.as\n    }\n\n    const { className = '' } = this.options\n\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this)\n\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim(),\n    })\n\n    this.editor.on('selectionUpdate', this.handleSelectionUpdate)\n    this.updateElementAttributes()\n  }\n\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    if (\n      this.renderer.element.firstElementChild &&\n      !this.renderer.element.firstElementChild?.hasAttribute('data-node-view-wrapper')\n    ) {\n      throw Error('Please use the NodeViewWrapper component for your node view.')\n    }\n\n    return this.renderer.element\n  }\n\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null\n    }\n\n    return this.contentDOMElement\n  }\n\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    if (this.selectionRafId) {\n      cancelAnimationFrame(this.selectionRafId)\n      this.selectionRafId = null\n    }\n\n    this.selectionRafId = requestAnimationFrame(() => {\n      this.selectionRafId = null\n      const { from, to } = this.editor.state.selection\n      const pos = this.getPos()\n      if (typeof pos !== 'number') {\n        return\n      }\n\n      if (from <= pos && to >= pos + this.node.nodeSize) {\n        if (this.renderer.props.selected) {\n          return\n        }\n\n        this.selectNode()\n      } else {\n        if (!this.renderer.props.selected) {\n          return\n        }\n\n        this.deselectNode()\n      }\n    })\n  }\n\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node: Node, decorations: readonly Decoration[], innerDecorations: DecorationSource): boolean {\n    const rerenderComponent = (props?: Record<string, any>) => {\n      this.renderer.updateProps(props)\n      if (typeof this.options.attrs === 'function') {\n        this.updateElementAttributes()\n      }\n    }\n\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    if (typeof this.options.update === 'function') {\n      const oldNode = this.node\n      const oldDecorations = this.decorations\n      const oldInnerDecorations = this.innerDecorations\n\n      this.node = node\n      this.decorations = decorations\n      this.innerDecorations = innerDecorations\n\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () =>\n          rerenderComponent({ node, decorations, innerDecorations, extension: this.extensionWithSyncedStorage }),\n      })\n    }\n\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true\n    }\n\n    this.node = node\n    this.decorations = decorations\n    this.innerDecorations = innerDecorations\n\n    rerenderComponent({ node, decorations, innerDecorations, extension: this.extensionWithSyncedStorage })\n\n    return true\n  }\n\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true,\n    })\n    this.renderer.element.classList.add('ProseMirror-selectednode')\n  }\n\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false,\n    })\n    this.renderer.element.classList.remove('ProseMirror-selectednode')\n  }\n\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy()\n    this.editor.off('selectionUpdate', this.handleSelectionUpdate)\n    this.contentDOMElement = null\n\n    if (this.selectionRafId) {\n      cancelAnimationFrame(this.selectionRafId)\n      this.selectionRafId = null\n    }\n  }\n\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj: Record<string, string> = {}\n\n      if (typeof this.options.attrs === 'function') {\n        const extensionAttributes = this.editor.extensionManager.attributes\n        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes)\n\n        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes })\n      } else {\n        attrsObj = this.options.attrs\n      }\n\n      this.renderer.updateAttributes(attrsObj)\n    }\n  }\n}\n\n/**\n * Create a React node view renderer.\n */\nexport function ReactNodeViewRenderer<T = HTMLElement>(\n  component: ComponentType<ReactNodeViewProps<T>>,\n  options?: Partial<ReactNodeViewRendererOptions>,\n): NodeViewRenderer {\n  return props => {\n    // try to get the parent component\n    // this is important for vue devtools to show the component hierarchy correctly\n    // maybe its `undefined` because <editor-content> isnt rendered yet\n    if (!(props.editor as EditorWithContentComponent).contentComponent) {\n      return {} as unknown as ProseMirrorNodeView\n    }\n\n    return new ReactNodeView<T>(component, props, options)\n  }\n}\n","import type { ReactNode } from 'react'\nimport { createContext, useContext, useMemo } from 'react'\n\nimport { EditorContext } from './Context.js'\nimport type { Editor, EditorContentProps, EditorStateSnapshot } from './index.js'\nimport { EditorContent, useEditorState } from './index.js'\n\n/**\n * The shape of the React context used by the `<Tiptap />` components.\n *\n * The editor instance is always available when using the default `useEditor`\n * configuration. For SSR scenarios where `immediatelyRender: false` is used,\n * consider using the legacy `EditorProvider` pattern instead.\n */\nexport type TiptapContextType = {\n  /** The Tiptap editor instance. */\n  editor: Editor\n}\n\n/**\n * React context that stores the current editor instance.\n *\n * Use `useTiptap()` to read from this context in child components.\n */\nexport const TiptapContext = createContext<TiptapContextType>({\n  get editor(): Editor {\n    throw new Error('useTiptap must be used within a <Tiptap> provider')\n  },\n})\n\nTiptapContext.displayName = 'TiptapContext'\n\n/**\n * Hook to read the Tiptap context and access the editor instance.\n *\n * This is a small convenience wrapper around `useContext(TiptapContext)`.\n * The editor is always available when used within a `<Tiptap>` provider.\n *\n * @returns The current `TiptapContextType` value from the provider.\n *\n * @example\n * ```tsx\n * import { useTiptap } from '@tiptap/react'\n *\n * function Toolbar() {\n *   const { editor } = useTiptap()\n *\n *   return (\n *     <button onClick={() => editor.chain().focus().toggleBold().run()}>\n *       Bold\n *     </button>\n *   )\n * }\n * ```\n */\nexport const useTiptap = () => useContext(TiptapContext)\n\n/**\n * Select a slice of the editor state using the context-provided editor.\n *\n * This is a thin wrapper around `useEditorState` that reads the `editor`\n * instance from `useTiptap()` so callers don't have to pass it manually.\n *\n * @typeParam TSelectorResult - The type returned by the selector.\n * @param selector - Function that receives the editor state snapshot and\n *                   returns the piece of state you want to subscribe to.\n * @param equalityFn - Optional function to compare previous/next selected\n *                     values and avoid unnecessary updates.\n * @returns The selected slice of the editor state.\n *\n * @example\n * ```tsx\n * function WordCount() {\n *   const wordCount = useTiptapState(state => {\n *     const text = state.editor.state.doc.textContent\n *     return text.split(/\\s+/).filter(Boolean).length\n *   })\n *\n *   return <span>{wordCount} words</span>\n * }\n * ```\n */\nexport function useTiptapState<TSelectorResult>(\n  selector: (context: EditorStateSnapshot<Editor>) => TSelectorResult,\n  equalityFn?: (a: TSelectorResult, b: TSelectorResult | null) => boolean,\n) {\n  const { editor } = useTiptap()\n\n  return useEditorState({\n    editor,\n    selector,\n    equalityFn,\n  })\n}\n\n/**\n * Props for the `Tiptap` root/provider component.\n */\nexport type TiptapWrapperProps = {\n  /**\n   * The editor instance to provide to child components.\n   * Use `useEditor()` to create this instance.\n   */\n  editor?: Editor\n\n  /**\n   * @deprecated Use `editor` instead. Will be removed in the next major version.\n   */\n  instance?: Editor\n\n  children: ReactNode\n}\n\n/**\n * Top-level provider component that makes the editor instance available via\n * React context to all child components.\n *\n * This component also provides backwards compatibility with the legacy\n * `EditorContext`, so components using `useCurrentEditor()` will work\n * inside a `<Tiptap>` provider.\n *\n * @param props - Component props.\n * @returns A context provider element wrapping `children`.\n *\n * @example\n * ```tsx\n * import { Tiptap, useEditor } from '@tiptap/react'\n *\n * function App() {\n *   const editor = useEditor({ extensions: [...] })\n *\n *   return (\n *     <Tiptap editor={editor}>\n *       <Toolbar />\n *       <Tiptap.Content />\n *     </Tiptap>\n *   )\n * }\n * ```\n */\nexport function TiptapWrapper({ editor, instance, children }: TiptapWrapperProps) {\n  const resolvedEditor = editor ?? instance\n\n  if (!resolvedEditor) {\n    throw new Error('Tiptap: An editor instance is required. Pass a non-null `editor` prop.')\n  }\n\n  const tiptapContextValue = useMemo<TiptapContextType>(() => ({ editor: resolvedEditor }), [resolvedEditor])\n\n  // Provide backwards compatibility with the legacy EditorContext\n  // so components using useCurrentEditor() work inside <Tiptap>\n  const legacyContextValue = useMemo(() => ({ editor: resolvedEditor }), [resolvedEditor])\n\n  return (\n    <EditorContext.Provider value={legacyContextValue}>\n      <TiptapContext.Provider value={tiptapContextValue}>{children}</TiptapContext.Provider>\n    </EditorContext.Provider>\n  )\n}\n\nTiptapWrapper.displayName = 'Tiptap'\n\n/**\n * Convenience component that renders `EditorContent` using the context-provided\n * editor instance. Use this instead of manually passing the `editor` prop.\n *\n * @param props - All `EditorContent` props except `editor` and `ref`.\n * @returns An `EditorContent` element bound to the context editor.\n *\n * @example\n * ```tsx\n * // inside a Tiptap provider\n * <Tiptap.Content className=\"editor\" />\n * ```\n */\nexport function TiptapContent({ ...rest }: Omit<EditorContentProps, 'editor' | 'ref'>) {\n  const { editor } = useTiptap()\n\n  return <EditorContent editor={editor} {...rest} />\n}\n\nTiptapContent.displayName = 'Tiptap.Content'\n\n/**\n * Root `Tiptap` component. Use it as the provider for all child components.\n *\n * The exported object includes the `Content` subcomponent for rendering the\n * editor content area.\n *\n * This component provides both the new `TiptapContext` (accessed via `useTiptap()`)\n * and the legacy `EditorContext` (accessed via `useCurrentEditor()`) for\n * backwards compatibility.\n *\n * For bubble menus and floating menus, import them separately from\n * `@tiptap/react/menus` to keep floating-ui as an optional dependency.\n *\n * @example\n * ```tsx\n * import { Tiptap, useEditor } from '@tiptap/react'\n * import { BubbleMenu } from '@tiptap/react/menus'\n *\n * function App() {\n *   const editor = useEditor({ extensions: [...] })\n *\n *   return (\n *     <Tiptap editor={editor}>\n *       <Tiptap.Content />\n *       <BubbleMenu>\n *         <button onClick={() => editor.chain().focus().toggleBold().run()}>Bold</button>\n *       </BubbleMenu>\n *     </Tiptap>\n *   )\n * }\n * ```\n */\nexport const Tiptap = Object.assign(TiptapWrapper, {\n  /**\n   * The Tiptap Content component that renders the EditorContent with the editor instance from the context.\n   * @see TiptapContent\n   */\n  Content: TiptapContent,\n})\n\nexport default Tiptap\n","function _objectDestructuringEmpty(t) {\n  if (null == t) throw new TypeError(\"Cannot destructure \" + t);\n}\nexport { _objectDestructuringEmpty as default };"],"names":["React","require","objectIs","Object","is","x","y","useState","useEffect","useLayoutEffect","useDebugValue","checkIfSnapshotChanged","inst","latestGetSnapshot","getSnapshot","value","nextValue","error","shim","window","document","createElement","subscribe","_useState","forceUpdate","exports","useSyncExternalStore","useRef","useMemo","useSyncExternalStoreWithSelector","getServerSnapshot","selector","isEqual","instRef","current","hasValue","memoizedSelector","nextSnapshot","hasMemo","memoizedSnapshot","currentSelection","memoizedSelection","nextSelection","maybeGetServerSnapshot","module","getOwnPropertyNames","getOwnPropertySymbols","hasOwnProperty","prototype","combineComparators","comparatorA","comparatorB","a","b","state","createIsCircular","areItemsEqual","cache","cachedA","get","cachedB","set","result","delete","getStrictProperties","object","concat","hasOwn","property","call","sameValueZeroEqual","getOwnPropertyDescriptor","keys","areArrayBuffersEqual","byteLength","areTypedArraysEqual","Uint8Array","areArraysEqual","index","length","equals","areDataViewsEqual","buffer","byteOffset","areDatesEqual","getTime","areErrorsEqual","name","message","cause","stack","areFunctionsEqual","areMapsEqual","size","matchedIndices","Array","aIterable","entries","aResult","bResult","next","done","bIterable","hasMatch","matchIndex","aEntry","bEntry","areNumbersEqual","areObjectsEqual","properties","isPropertyEqual","areObjectsEqualStrict","descriptorA","descriptorB","configurable","enumerable","writable","arePrimitiveWrappersEqual","valueOf","areRegExpsEqual","source","flags","areSetsEqual","values","areUrlsEqual","hostname","pathname","protocol","port","hash","username","password","$$typeof","TYPED_ARRAY_TAGS","toString","createEqualityComparator","_ref","unknownTagComparators","type","constructor","isArray","Date","RegExp","Map","Set","tag","then","unknownTagComparator","shortTag","Symbol","toStringTag","undefined","deepEqual","createCustomEqual","strict","circular","createInternalComparator","options","arguments","createCustomInternalComparator","createState","config","_ref2","createCustomConfig","assign","createEqualityComparatorConfig","comparator","compare","_ref3","WeakMap","meta","createIsEqual","_indexOrKeyA","_indexOrKeyB","_parentA","_parentB","mergeRefs","_len","refs","_key","node","forEach","ref","Portals","contentComponent","renderers","jsx","Fragment","children","PureEditorContent","props","_a","super","this","editorContentRef","initialized","hasContentComponentInitialized","Boolean","editor","componentDidMount","init","componentDidUpdate","isDestroyed","view","dom","parentNode","element","append","childNodes","setOptions","subscribers","callback","add","setRenderer","id","renderer","_objectSpread","ReactDOM","reactElement","subscriber","removeRenderer","nextRenderers","getInstance","unsubscribeToContentComponent","setState","prevState","createNodeViews","componentWillUnmount","setProps","nodeViews","newElement","_unused","render","_this$props","innerRef","rest","_objectWithoutProperties","_excluded","jsxs","EditorContentWithKey","forwardRef","key","Math","floor","random","EditorContent","useIsomorphicLayoutEffect","EditorStateManager","initialEditor","transactionNumber","lastTransactionNumber","lastSnapshot","bind","watch","nextEditor","fn","currentEditor","on","off","useEditorState","editorStateManager","selectedState","equalityFn","isSSR","isNext","EditorInstanceManager","_EditorInstanceManager","subscriptions","isComponentMounted","previousDeps","instanceId","setEditor","getInitialEditor","scheduleDestroy","getEditor","refreshEditorInstance","onRender","createEditor","slice","cb","immediatelyRender","_this","optionsToApply","onBeforeCreate","_b","_len2","args","_key2","onBlur","_len3","_key3","onCreate","_len4","_key4","onDestroy","_len5","_key5","onFocus","_len6","_key6","onSelectionUpdate","_len7","_key7","onTransaction","_len8","_key8","onUpdate","_len9","_key9","onContentError","_len0","_key0","onDrop","_len1","_key1","onPaste","_len10","_key10","onDelete","_len11","_key11","Editor","onStoreChange","compareOptions","every","includes","extensions","extension","deps","clearTimeout","scheduledDestructionTimeout","editable","isEditable","dep","destroy","currentInstanceId","setTimeout","useEditor","mostRecentOptions","instanceManager","useState2","useSyncExternalStore2","useDebugValue2","useEffect2","shouldRerenderOnTransaction","EditorContext","createContext","Consumer","ReactNodeViewContext","createContext2","onDragStart","nodeViewContentChildren","nodeViewContentRef","useReactNodeView","useContext2","React3","Tag","as","jsx4","style","whiteSpace","isClassComponent","Component","isReactComponent","isForwardRefComponent","description","ReactRenderer","component","_ref7","className","destroyed","classList","split","isInitialized","flushSync","queueMicrotask","isReact19","reactVersion","parseInt","_unused2","isReact19Plus","componentCanReceiveRef","isMemoComponent","wrappedComponent","canReceiveRef","elementProps","jsx5","updateProps","removeChild","_unused3","updateAttributes","attributes","setAttribute","ReactMarkViewContext","React4","markViewContentRef","MarkView","NodeView","TiptapContext","createContext3","Error","displayName","useTiptap","useContext3","TiptapWrapper","_ref8","instance","resolvedEditor","tiptapContextValue","useMemo2","legacyContextValue","jsx8","Provider","TiptapContent","_ref9","t","TypeError","_objectDestructuringEmpty","Content"],"sourceRoot":""}