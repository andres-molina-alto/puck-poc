{"version":3,"file":"static/js/308.f9198041.chunk.js","mappings":"sLA6BO,SAASA,EAAaC,EAAkBC,GAC7C,GAAsB,qBAAXC,OACT,MAAM,IAAIC,MACR,wJAIJ,MAAMC,GAASC,EAAAA,EAAAA,IAAUJ,GAGzB,OCxBK,SAA6BD,EAAWI,EAAgBE,GAC7D,GAAsB,qBAAXJ,OACT,MAAM,IAAIC,MACR,+JAIJ,GAAI,MAAAG,OAAA,EAAAA,EAASC,SAAU,CACrB,MAAMC,EAAOF,EAAQC,SAASE,cAAc,OAG5C,OADAC,EAAAA,GAAcC,WAAWP,GAAQQ,kBAAkBZ,EAAIa,QAAS,CAAEN,SAAUD,EAAQC,UAAYC,GACzFA,EAAKM,SACd,CAEA,MAAMC,EAAWL,EAAAA,GAAcC,WAAWP,GAAQQ,kBAAkBZ,EAAIa,QAAS,CAC/EN,SAAUL,OAAOK,WAKnB,OAFmB,IAAIS,eAELC,kBAAkBF,EACtC,CDGSG,CAFaC,EAAAA,GAAKC,SAAShB,EAAQJ,GAEFI,EAC1C,C,sBE1BAiB,EAAAA,EAAAA,MAIA,IAAIC,GAAeC,EAAAA,EAAAA,GAA+B,iBAAkBC,EAAAA,GACpE,SAASC,EAAcC,GAGpB,IAHqB,QACtBb,EAAO,MACPc,GACDD,EACC,MAAM,OAAEE,EAAS,CAAC,EAAC,QAAEtB,GAAYqB,GAC3B,WAAE1B,EAAa,IAAO2B,EACtBC,GAAmBC,EAAAA,EAAAA,SACvB,IAAM,CAACC,EAAAA,EAAaC,UAAU1B,MAAaL,GAC3C,CAAC0B,EAAO1B,IAEJgC,GAAaH,EAAAA,EAAAA,SAAQ,KACzB,GAAuB,kBAAZjB,GAAsE,SAAlC,MAAXA,OAAuB,EAAIA,EAAQqB,MACrE,OAAOrB,EAET,GAAuB,kBAAZA,EAAsB,CAE/B,MADe,qBAAqBsB,KAAKtB,GCjBxC,SAAsBuB,EAAcnC,EAAwBK,GACjE,GAAsB,qBAAXJ,OACT,MAAM,IAAIC,MACR,wJAIJ,MAAMC,GAASiC,EAAAA,EAAAA,IAAUpC,GACnBD,GAAgB,IAAIE,OAAOoC,WAAYC,gBAAgBH,EAAM,aAEnE,IAAKpC,EACH,MAAM,IAAIG,MAAM,+BAGlB,OAAOmC,EAAAA,GAAU3B,WAAWP,GACzBoC,MAAMxC,EAAIyC,KAAcnC,GACxBoC,QACL,CDEeC,CAAa9B,EAASgB,GAExB,CACLK,KAAM,MACNrB,QAAS,CACP,CAAEqB,KAAM,YAAarB,QAAS,CAAC,CAAEqB,KAAM,OAAQU,KAAM/B,MAG3D,CACA,MAAO,CAAEqB,KAAM,MAAOrB,QAAS,KAC9B,CAACA,EAASgB,IACPO,GAAON,EAAAA,EAAAA,SAAQ,IACZ/B,EAAakC,EAAYJ,GAC/B,CAACI,EAAYJ,IAChB,OAAuBgB,EAAAA,EAAAA,KAAI,MAAO,CAAEC,UAAWxB,IAAgByB,UAA0BF,EAAAA,EAAAA,KAAI,MAAO,CAAEC,UAAW,YAAaE,wBAAyB,CAAEC,OAAQb,MACnK,C","sources":["../node_modules/@tiptap/html/src/generateHTML.ts","../node_modules/@tiptap/html/src/getHTMLFromFragment.ts","../node_modules/@puckeditor/core/dist/Render-CU35UAWV.mjs","../node_modules/@tiptap/html/src/generateJSON.ts"],"sourcesContent":["import type { Extensions, JSONContent } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\n\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\n\n/**\n * Generates HTML from a ProseMirror JSON content object.\n * @param doc - The ProseMirror JSON content object.\n * @param extensions - The Tiptap extensions used to build the schema.\n * @returns The generated HTML string.\n * @example\n * const doc = {\n *   type: 'doc',\n *   content: [\n *     {\n *       type: 'paragraph',\n *       content: [\n *         {\n *           type: 'text',\n *           text: 'Hello world!'\n *         }\n *       ]\n *     }\n *   ]\n * }\n * const extensions = [...]\n * const html = generateHTML(doc, extensions)\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'generateHTML can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import type { Node, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\n\n/**\n * Returns the HTML string representation of a given document node.\n *\n * @param doc - The document node to serialize.\n * @param schema - The Prosemirror schema to use for serialization.\n * @returns The HTML string representation of the document fragment.\n *\n * @example\n * ```typescript\n * const html = getHTMLFromFragment(doc, schema)\n * ```\n */\nexport function getHTMLFromFragment(doc: Node, schema: Schema, options?: { document?: Document }): string {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'getHTMLFromFragment can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  if (options?.document) {\n    const wrap = options.document.createElement('div')\n\n    DOMSerializer.fromSchema(schema).serializeFragment(doc.content, { document: options.document }, wrap)\n    return wrap.innerHTML\n  }\n\n  const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content, {\n    document: window.document as unknown as Document,\n  })\n\n  const serializer = new XMLSerializer()\n\n  return serializer.serializeToString(fragment as any)\n}\n","import {\n  PuckRichText\n} from \"./chunk-2CNEFIQP.mjs\";\nimport {\n  styles_module_default\n} from \"./chunk-AOEDIUVK.mjs\";\nimport {\n  get_class_name_factory_default\n} from \"./chunk-Y2EFNT5P.mjs\";\nimport {\n  init_react_import\n} from \"./chunk-M6W7YEVX.mjs\";\n\n// components/RichTextEditor/components/Render.tsx\ninit_react_import();\nimport { generateHTML, generateJSON } from \"@tiptap/html\";\nimport { useMemo } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getClassName = get_class_name_factory_default(\"RichTextEditor\", styles_module_default);\nfunction RichTextRender({\n  content,\n  field\n}) {\n  const { tiptap = {}, options } = field;\n  const { extensions = [] } = tiptap;\n  const loadedExtensions = useMemo(\n    () => [PuckRichText.configure(options), ...extensions],\n    [field, extensions]\n  );\n  const normalized = useMemo(() => {\n    if (typeof content === \"object\" && (content == null ? void 0 : content.type) === \"doc\") {\n      return content;\n    }\n    if (typeof content === \"string\") {\n      const isHtml = /<\\/?[a-z][\\s\\S]*>/i.test(content);\n      if (isHtml) {\n        return generateJSON(content, loadedExtensions);\n      }\n      return {\n        type: \"doc\",\n        content: [\n          { type: \"paragraph\", content: [{ type: \"text\", text: content }] }\n        ]\n      };\n    }\n    return { type: \"doc\", content: [] };\n  }, [content, loadedExtensions]);\n  const html = useMemo(() => {\n    return generateHTML(normalized, loadedExtensions);\n  }, [normalized, loadedExtensions]);\n  return /* @__PURE__ */ jsx(\"div\", { className: getClassName(), children: /* @__PURE__ */ jsx(\"div\", { className: \"rich-text\", dangerouslySetInnerHTML: { __html: html } }) });\n}\nexport {\n  RichTextRender\n};\n","import type { Extensions } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport type { ParseOptions } from '@tiptap/pm/model'\nimport { DOMParser } from '@tiptap/pm/model'\n\n/**\n * Generates a JSON object from the given HTML string and converts it into a Prosemirror node with content.\n * @param {string} html - The HTML string to be converted into a Prosemirror node.\n * @param {Extensions} extensions - The extensions to be used for generating the schema.\n * @param {ParseOptions} options - The options to be supplied to the parser.\n * @returns {Record<string, any>} - The generated JSON object.\n * @example\n * const html = '<p>Hello, world!</p>'\n * const extensions = [...]\n * const json = generateJSON(html, extensions)\n * console.log(json) // { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }] }\n */\nexport function generateJSON(html: string, extensions: Extensions, options?: ParseOptions): Record<string, any> {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'generateJSON can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const doc: Document = new window.DOMParser().parseFromString(html, 'text/html')\n\n  if (!doc) {\n    throw new Error('Failed to parse HTML string')\n  }\n\n  return DOMParser.fromSchema(schema)\n    .parse(doc.body as Node, options)\n    .toJSON()\n}\n"],"names":["generateHTML","doc","extensions","window","Error","schema","getSchema","options","document","wrap","createElement","DOMSerializer","fromSchema","serializeFragment","content","innerHTML","fragment","XMLSerializer","serializeToString","getHTMLFromFragment","Node","fromJSON","init_react_import","getClassName","get_class_name_factory_default","styles_module_default","RichTextRender","_ref","field","tiptap","loadedExtensions","useMemo","PuckRichText","configure","normalized","type","test","html","getSchema2","DOMParser","parseFromString","parse","body","toJSON","generateJSON","text","jsx","className","children","dangerouslySetInnerHTML","__html"],"sourceRoot":""}